# Story 2.13: Manual Testing Bug Fixes

## Status
**Draft**

## Story

**As a** MessageAI user,
**I want** all critical bugs found during manual testing to be fixed,
**so that** the app is stable, reliable, and provides a consistent offline/online experience.

## Acceptance Criteria

### Critical (P0) - Must Fix
1. **Message Freeze Fix**: Rapidly adding messages no longer causes the app to freeze
2. **Duplicate Conversation Prevention**: Toggling connection does not create duplicate conversations in the list
3. **Message Scroll Data Loss**: Scrolling through 50 messages does not delete the conversation

### High Priority (P1) - Should Fix
4. **Offline Banner Persistence**: Offline banner properly disappears when connection is restored
5. **Image Attachment Display**: Image attachments display correctly, not as empty messages
6. **User Image Identity**: User profile images consistently map to the correct user
7. **Group Conversation Title**: Group conversation titles display correctly immediately on load (no race condition)
8. **Typing Indicator Layout**: Typing indicator does not cause whitespace UI bug below message box

### Medium Priority (P2) - Nice to Have
9. **Offline Banner Consistency**: Offline banner appears at the topmost point across all modals (conversation list, conversation detail, new message modal)
10. **Offline Banner Responsiveness**: Offline banner appears immediately (< 1 second) when disconnected
11. **Offline Cache Loading**: Conversations list loads from cache when offline
12. **Profile Image State**: App correctly checks for existing profile image before prompting re-upload
13. **Retry UX Consistency**: Retry option behavior is consistent and predictable across all error scenarios

### Feature Gaps (P3) - Future Stories
14. **Message Pagination**: Load more messages beyond initial 50 (defer to future story)
15. **Notification Badges**: Implement badge system (defer to future story)

## Tasks / Subtasks

### Critical Fixes (P0)

- [ ] **Task 1: Fix Message Freeze on Rapid Adds** (AC: 1)
  - [ ] Investigate ChatViewModel message handling for race conditions
  - [ ] Review FirebaseMessageRepository batch write implementation
  - [ ] Add debouncing/throttling to rapid message sends if needed
  - [ ] Add performance test for rapid message sending (50 messages in 10 seconds)
  - [ ] Verify UI remains responsive during bulk message operations

- [ ] **Task 2: Prevent Duplicate Conversations** (AC: 2)
  - [ ] Review ConversationListViewModel deduplication logic
  - [ ] Audit FirebaseConversationRepository snapshot listener handling
  - [ ] Implement conversation ID-based deduplication in ViewModel
  - [ ] Add integration test: toggle connection 5x, verify single conversation instance
  - [ ] Review Firestore query for conversation list (check for duplicate subscriptions)

- [ ] **Task 3: Fix Conversation Deletion on Scroll** (AC: 3)
  - [ ] Investigate ChatViewModel pagination logic
  - [ ] Review message loading/unloading behavior
  - [ ] Ensure conversation document is never deleted during message fetch
  - [ ] Add integration test: load 50+ messages, scroll fully, verify conversation exists
  - [ ] Check for errant delete operations in scroll handlers

### High Priority Fixes (P1)

- [ ] **Task 4: Fix Offline Banner State Management** (AC: 4)
  - [ ] Review NetworkMonitor implementation
  - [ ] Audit offline banner binding to network state publisher
  - [ ] Ensure Combine subscriber properly updates on connection restore
  - [ ] Add test: disconnect → reconnect → verify banner dismisses within 2 seconds
  - [ ] Check for memory leaks in network state observers

- [ ] **Task 5: Fix Image Attachment Display** (AC: 5)
  - [ ] Review StorageRepositoryProtocol implementation
  - [ ] Audit image upload completion handler
  - [ ] Verify message object includes imageUrl after upload
  - [ ] Test image attachment flow end-to-end (upload → store URL → display)
  - [ ] Add error handling for failed image uploads with user feedback

- [ ] **Task 6: Fix User Image Identity Mapping** (AC: 6)
  - [ ] Investigate image caching mechanism
  - [ ] Review user ID → image URL mapping in UserViewModel
  - [ ] Check for race conditions in async image loading
  - [ ] Ensure cache keys use user ID, not message ID or other identifiers
  - [ ] Add test: verify correct image for 10 different users in conversation

- [ ] **Task 7: Fix Group Conversation Title Race Condition** (AC: 7)
  - [ ] Review ConversationViewModel initialization
  - [ ] Ensure group name loads before view renders
  - [ ] Add async/await proper sequencing for conversation metadata fetch
  - [ ] Test: open group conversation → verify title correct on first frame
  - [ ] Consider optimistic loading with cached title

- [ ] **Task 8: Fix Typing Indicator Layout Bug** (AC: 8)
  - [ ] Review TypingIndicatorView SwiftUI layout
  - [ ] Identify source of whitespace injection
  - [ ] Ensure typing indicator uses proper padding/spacing modifiers
  - [ ] Test: trigger typing indicator → verify no layout shift
  - [ ] Review ChatView VStack/ScrollView layout constraints

### Medium Priority Fixes (P2)

- [ ] **Task 9: Standardize Offline Banner Positioning** (AC: 9)
  - [ ] Audit all modal views (ConversationListView, ChatView, NewMessageView)
  - [ ] Create shared OfflineBannerModifier ViewModifier
  - [ ] Apply to topmost ZStack in each view
  - [ ] Test on all three screens with offline mode
  - [ ] **Note**: Requires architectural review by Winston (cross-cutting UI concern)

- [ ] **Task 10: Improve Offline Banner Responsiveness** (AC: 10)
  - [ ] Review NetworkMonitor polling/event frequency
  - [ ] Reduce detection latency to < 1 second
  - [ ] Add immediate state check on view appear
  - [ ] Test: disconnect → verify banner within 1 second
  - [ ] Consider NWPathMonitor for real-time network updates

- [ ] **Task 11: Enable Offline Cache for Conversations** (AC: 11)
  - [ ] Verify Firestore offline persistence is enabled
  - [ ] Review FirebaseConversationRepository cache configuration
  - [ ] Test: load conversations → go offline → relaunch app → verify cache load
  - [ ] Add error handling for cache miss scenarios
  - [ ] Document cache behavior in architecture

- [ ] **Task 12: Fix Profile Image State Check** (AC: 12)
  - [ ] Review profile setup flow logic
  - [ ] Add check for existing profileImageUrl in User entity before prompting upload
  - [ ] Update ProfileViewModel to skip upload prompt if image exists
  - [ ] Test: user with existing image → verify no re-upload prompt
  - [ ] Consider cache invalidation if user explicitly wants to change image

- [ ] **Task 13: Standardize Retry UX** (AC: 13)
  - [ ] Audit all error handling flows for retry patterns
  - [ ] Define consistent retry UX pattern (show retry button vs auto-retry)
  - [ ] Implement in MessageViewModel, ConversationViewModel, AuthViewModel
  - [ ] Test: trigger network error → verify consistent retry UI
  - [ ] **Note**: Requires UX decision - manual retry vs auto-retry on reconnect

### Feature Gap Tracking (P3)

- [ ] **Task 14: Create Story for Message Pagination** (AC: 14)
  - [ ] Document requirement: load more than 50 messages with "Load More" button
  - [ ] Defer implementation to future epic
  - [ ] Add to product backlog

- [ ] **Task 15: Create Story for Notification Badges** (AC: 15)
  - [ ] Document requirement: unread count badges on conversations
  - [ ] Defer implementation to future epic
  - [ ] Add to product backlog

## Dev Notes

### Architecture Context

**Affected Components:**
- **Presentation Layer**: ChatViewModel, ConversationListViewModel, ProfileViewModel
- **Data Layer**: FirebaseMessageRepository, FirebaseConversationRepository, FirebaseStorageRepository
- **Cross-Cutting**: NetworkMonitor, OfflineBanner (UI component)

**Key Architectural Principles to Follow:**
1. **Repository Abstraction**: All fixes must maintain protocol-based dependency injection
2. **Optimistic UI**: Message sends should remain optimistic (show immediately, save in background)
3. **@MainActor**: All ViewModel updates must be on MainActor for Swift 6 concurrency safety
4. **Error Handling**: NEVER silent failures - provide user feedback for all errors

### Relevant Source Files

**ViewModels:**
- `MessageAI/Presentation/ViewModels/ChatViewModel.swift` - Message freeze, typing indicator
- `MessageAI/Presentation/ViewModels/ConversationListViewModel.swift` - Duplicates, offline cache
- `MessageAI/Presentation/ViewModels/ProfileViewModel.swift` - Image re-upload prompt

**Repositories:**
- `MessageAI/Data/Repositories/FirebaseMessageRepository.swift` - Message operations
- `MessageAI/Data/Repositories/FirebaseConversationRepository.swift` - Conversation queries
- `MessageAI/Data/Repositories/FirebaseStorageRepository.swift` - Image upload/download

**Views:**
- `MessageAI/Presentation/Views/ChatView.swift` - Typing indicator layout, offline banner
- `MessageAI/Presentation/Views/ConversationListView.swift` - Offline banner, cache loading
- `MessageAI/Presentation/Components/TypingIndicatorView.swift` - Whitespace bug

**Network:**
- `MessageAI/Data/Network/NetworkMonitor.swift` - Offline detection and state management

**Entities:**
- `MessageAI/Domain/Entities/Message.swift` - Message status states
- `MessageAI/Domain/Entities/Conversation.swift` - Conversation deduplication
- `MessageAI/Domain/Entities/User.swift` - Profile image state

### Known Issues from Previous Stories

**From Story 2.9 (Offline Message Queue):**
- Offline persistence enabled but cache loading may not be fully implemented for conversation list
- Message queue uses optimistic UI pattern - ensure rapid sends don't break queue

**From Story 2.11 (Performance Optimization):**
- Performance baselines established (message send < 2s, conversation load < 1s)
- Rapid message test may have uncovered race condition in batch writes

**From Story 2.7 (Image Attachments):**
- Image upload uses StorageRepositoryProtocol
- Image URLs stored in Message entity's `imageUrl` field
- Cache invalidation may not be properly implemented

**From Story 2.6 (Typing Indicators):**
- TypingIndicatorView is a SwiftUI component
- Layout may conflict with message input box constraints

### Testing

**Test Coverage Requirements:**
- **Domain Layer**: 80%+ (focus on Message, Conversation entity logic)
- **Data Layer**: 70%+ (repository implementations for deduplication, caching)
- **Presentation Layer**: 75%+ (ViewModel state management, error handling)

**Test File Locations:**
```
MessageAITests/
├── Domain/Entities/
│   ├── MessageTests.swift
│   └── ConversationTests.swift
├── Data/Repositories/
│   ├── FirebaseMessageRepositoryTests.swift
│   ├── FirebaseConversationRepositoryTests.swift
│   └── FirebaseStorageRepositoryTests.swift
├── Presentation/ViewModels/
│   ├── ChatViewModelTests.swift
│   ├── ConversationListViewModelTests.swift
│   └── ProfileViewModelTests.swift
├── Performance/
│   └── RapidMessagePerformanceTests.swift
└── Integration/
    ├── OfflineModeIntegrationTests.swift
    └── ImageAttachmentIntegrationTests.swift
```

**Testing Standards:**
1. **Unit Tests**: Use MockMessageRepository, MockConversationRepository for ViewModel tests
2. **Integration Tests**: Require Firebase Emulator (`./scripts/start-emulator.sh`)
3. **Performance Tests**: Rapid message test (50 messages in 10 seconds), conversation scroll test
4. **Quick Testing**: Use `./scripts/quick-test.sh -q` for fast iteration during development

**Specific Test Scenarios:**

**Critical Tests (P0):**
- Rapid message send: 50 messages in 10 seconds without freeze
- Connection toggle: 5x offline/online cycles, verify 1 conversation instance
- Scroll pagination: Load 50+ messages, scroll to top/bottom, verify conversation persists

**High Priority Tests (P1):**
- Offline banner: Disconnect → verify banner appears → reconnect → verify banner disappears within 2s
- Image attachment: Upload image → send message → verify image displays (not empty)
- User image mapping: 10 users in conversation → verify each user has correct profile image
- Group title: Open group conversation → verify title correct on first render
- Typing indicator: Show typing indicator → verify no whitespace below input

**Medium Priority Tests (P2):**
- Offline banner positioning: Check banner on ConversationListView, ChatView, NewMessageView
- Offline responsiveness: Disconnect → verify banner within 1 second
- Cache loading: Load conversations → go offline → restart app → verify list populates from cache
- Profile image state: User with existing image → verify no re-upload prompt
- Retry consistency: Trigger error → verify retry UI appears consistently

**Performance Baselines (from Story 2.11):**
- Message send: < 2 seconds
- Conversation load (50 messages): < 1 second
- Rapid message send (50 messages): App remains responsive, no freeze

### Architectural Review Required

**For Winston (Architect):**
- **Task 9**: Offline banner positioning strategy across modals (cross-cutting UI concern)
- **Task 13**: Retry UX pattern standardization (auto-retry vs manual retry decision)
- **Task 6**: Image caching architecture review (identity mapping strategy)
- **Task 2**: Conversation deduplication pattern (repository vs ViewModel responsibility)

**For Quinn (QA):**
- **All Tasks**: Test coverage validation
- **Critical Bugs**: Risk assessment and gate decision
- **Performance Tests**: Baseline validation for rapid message scenarios

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Initial story creation from manual testing bug report | Quinn (QA Agent) |

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used
*(To be filled by Dev Agent)*

### Debug Log References
*(To be filled by Dev Agent)*

### Completion Notes List
*(To be filled by Dev Agent)*

### File List
*(To be filled by Dev Agent)*

## QA Results

*(This section will be populated by QA Agent after implementation review)*

---

**Next Steps:**
1. **Winston (Architect)** should review architectural decisions for Tasks 9, 13, 6, and 2
2. **Dev Agent** can begin implementation on P0 critical fixes (Tasks 1-3)
3. **Quinn (QA)** will perform comprehensive review and gate decision after implementation
