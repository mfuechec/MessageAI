# Story 6.6: Push Notification Delivery & Deep Linking

## Status

**Draft**

---

## Story

**As a** user,
**I want** to receive smart notifications on my device and tap to view the conversation,
**so that** I can quickly respond to important messages.

---

## Acceptance Criteria

**FCM Integration:**
1. Reuse existing FCM token registration from Story 2.10
2. Cloud Function `analyzeForNotification` sends FCM push when shouldNotify=true
3. FCM payload includes: `{ title: "MessageAI", body: notificationText, priority, conversationId, messageId }`

**Notification Presentation:**
4. High priority: Alert banner with sound
5. Medium priority: Silent notification in notification center
6. Low priority: Badge update only (no banner/sound)
7. Notification includes sender avatar (if available)
8. Notification grouped by conversation (iOS notification grouping)

**Interactive Notification Actions:**
9. Action buttons: "üëç Helpful" | "üëé Not Helpful" (Story 6.5 feedback)
10. Quick reply action: "Reply" opens text input, sends message directly from notification
    - Extract reply text from UNTextInputNotificationResponse
    - Use current logged-in user from DIContainer.shared.currentUserId
    - Send message via MessageRepository.sendMessage()
    - Show confirmation notification: "Message sent"
    - **Error handling:** If send fails, show error notification and open app to conversation
11. Mark as read action: "Mark Read" dismisses notification, marks messages as read in Firestore

**Deep Linking:**
12. Tap notification opens app to specific conversation
13. Scrolls to specific message that triggered notification (messageId in payload)
14. Highlights message briefly (yellow flash animation)
15. Deep link works when app is closed, backgrounded, or active

**Notification Suppression:**
16. If user is actively viewing conversation, don't call Cloud Function (client-side check in Story 6.1)
17. **Backup server-side check:** Cloud Function queries Firestore `user_activity` collection as fallback safety net
18. Update `user_activity` on conversation view appear/disappear (write when ChatView.onAppear, delete on onDisappear)
19. Activity considered stale after 2 minutes (Cloud Function checks timestamp before suppressing)

**Quiet Hours:**
20. Cloud Function checks user's quiet hours preference before sending notification
21. If current time within quiet hours AND priority < high: Don't send notification
22. High priority notifications bypass quiet hours (urgent messages)

**Rate Limiting:**
23. Enforce maxAnalysesPerHour limit from user preferences
    - Implemented in Cloud Function (server-side)
    - Track in Firestore: `rate_limits/{userId}` with count and hourly reset
24. If limit exceeded, return error to client with fallback strategy preference
    - Client applies fallback: simple_rules, notify_all, or suppress_all (from Story 6.4)
    - Client shows banner in-app: "‚ö†Ô∏è Smart notification limit reached (10/hour). Using simple rules."
25. Reset counter every hour (use Firestore document TTL or check timestamp on each request)

**Testing:**
26. Integration test: Notification delivered with correct priority
27. Integration test: Tap notification deep links to conversation
28. Integration test: Feedback buttons send correct data
29. Integration test: Quick reply sends message successfully (verify authentication)
30. Integration test: Active conversation suppression works (client-side + server-side backup)
31. Integration test: Quiet hours suppress non-urgent notifications
32. Integration test: Rate limiting enforced correctly
33. UI test: Notification displays with correct text and actions

---

## Tasks / Subtasks

- [ ] Integrate FCM notification sending into Cloud Function (AC: 1-3)
  - [ ] Import Firebase Admin SDK in Cloud Function
  - [ ] Load user's FCM token from Firestore `users/{userId}/fcmToken`
  - [ ] Build FCM payload: title, body, priority, data (conversationId, messageId)
  - [ ] Call `admin.messaging().send()` when shouldNotify=true
  - [ ] Handle errors: Invalid token, token expired, user uninstalled app

- [ ] Implement priority-based notification presentation (AC: 4-6)
  - [ ] Map AI priority to FCM priority:
    - high ‚Üí `"high"` (banner + sound)
    - medium ‚Üí `"default"` (silent)
    - low ‚Üí badge only (skip FCM, update badge locally)
  - [ ] Set notification sound based on priority
  - [ ] Update badge count on notification delivery

- [ ] Add sender avatar to notifications (AC: 7)
  - [ ] Load sender's profile image URL from Firestore
  - [ ] Include in FCM payload: `image: senderAvatarUrl`
  - [ ] iOS: Use UNNotificationAttachment for avatar display

- [ ] Implement conversation grouping (AC: 8)
  - [ ] Set FCM `threadId` to conversationId
  - [ ] iOS: Use `UNNotificationContent.threadIdentifier`
  - [ ] Multiple notifications from same conversation group together

- [ ] Add interactive notification actions (AC: 9-11, Story 6.5 integration)
  - [ ] Reuse feedback actions from Story 6.5: "üëç Helpful" | "üëé Not Helpful"
  - [ ] Add quick reply action: `UNTextInputNotificationAction`
  - [ ] Add mark as read action: `UNNotificationAction`
  - [ ] Set category: `"SMART_NOTIFICATION_CATEGORY"`

- [ ] Implement quick reply handler (AC: 10)
  - [ ] In AppDelegate, handle `UNTextInputNotificationResponse`
  - [ ] Extract reply text from response
  - [ ] Send message via `MessageRepository.sendMessage()`
  - [ ] Show confirmation: "Message sent"

- [ ] Implement mark as read handler (AC: 11)
  - [ ] In AppDelegate, handle "MARK_READ_ACTION"
  - [ ] Extract conversationId and messageId from userInfo
  - [ ] Call `MessageRepository.markAsRead()`
  - [ ] Remove notification from notification center

- [ ] Implement deep linking (AC: 12-15)
  - [ ] Update AppDelegate to handle notification tap
  - [ ] Extract conversationId and messageId from userInfo
  - [ ] Navigate to ChatView with conversationId
  - [ ] Scroll to specific message using messageId
  - [ ] Highlight message with animation (yellow flash, fade out)
  - [ ] Handle all app states: closed, backgrounded, foreground

- [ ] Add message highlight animation (AC: 14)
  - [ ] Create `MessageHighlightModifier` SwiftUI modifier
  - [ ] Apply yellow background with fade animation
  - [ ] Duration: 2 seconds (flash 0.5s, hold 1s, fade 0.5s)
  - [ ] Scroll to message before highlighting

- [ ] Implement active conversation suppression (AC: 16-18)
  - [ ] Create Firestore collection: `user_activity/{userId}`
  - [ ] Schema: `{ userId, activeConversationId, timestamp }`
  - [ ] Update in ChatView.onAppear: Set activeConversationId
  - [ ] Update in ChatView.onDisappear: Clear activeConversationId
  - [ ] In Cloud Function: Check user_activity before sending notification
  - [ ] If activeConversationId == conversationId: Skip notification

- [ ] Implement quiet hours check (AC: 19-21)
  - [ ] In Cloud Function, load user preferences
  - [ ] Parse quietHoursStart, quietHoursEnd, timezone
  - [ ] Calculate current time in user's timezone
  - [ ] If within quiet hours AND priority != "high": Skip notification
  - [ ] Log: "Notification suppressed due to quiet hours"

- [ ] Implement rate limiting (AC: 22-24)
  - [ ] In Cloud Function, track analyses per hour per user
  - [ ] Use Firestore: `rate_limits/{userId}` with count and reset timestamp
  - [ ] If count >= maxAnalysesPerHour: Return error or fallback
  - [ ] Reset count every hour (use scheduled function or TTL)
  - [ ] Optional: Send notification to user about rate limit

- [ ] Write integration tests (AC: 25-30)
  - [ ] Test: Notification sent with correct priority
  - [ ] Test: High priority notification has sound
  - [ ] Test: Medium priority notification is silent
  - [ ] Test: Tap notification navigates to conversation
  - [ ] Test: Scroll to correct message on deep link
  - [ ] Test: Feedback buttons submit feedback
  - [ ] Test: Quick reply sends message
  - [ ] Test: Mark as read updates Firestore
  - [ ] Test: Active conversation suppression works
  - [ ] Test: Quiet hours suppress medium/low priority

- [ ] Write UI tests (AC: 31)
  - [ ] Test: Notification displays with correct text
  - [ ] Test: Notification shows sender avatar
  - [ ] Test: Action buttons appear
  - [ ] Test: Tap notification opens app
  - [ ] Test: Message highlighted on deep link

---

## Dev Notes

### Architecture Context

**Notification Delivery Flow:**
```
analyzeForNotification Cloud Function (Story 6.3)
  ‚Üì (shouldNotify = true)
Check active conversation suppression
  ‚Üì (not active)
Check quiet hours
  ‚Üì (not quiet hours OR priority = high)
Check rate limit
  ‚Üì (under limit)
Load user's FCM token
  ‚Üì
Send FCM notification
  ‚Üì
User's device receives notification
  ‚Üì
User taps notification
  ‚Üì
AppDelegate handles deep link
  ‚Üì
Navigate to ChatView, scroll to message, highlight
```

**Deep Linking Flow:**
```
User taps notification
  ‚Üì
AppDelegate.userNotificationCenter(_:didReceive:)
  ‚Üì
Extract conversationId, messageId from userInfo
  ‚Üì
Post NotificationCenter event: .openConversation
  ‚Üì
RootView observes event
  ‚Üì
NavigationState updates: selectedConversationId
  ‚Üì
ChatView appears, scrolls to messageId, highlights
```

### Relevant Source Tree

**New Files:**
- `MessageAI/Presentation/Modifiers/MessageHighlightModifier.swift`
- `MessageAI/Presentation/Services/DeepLinkHandler.swift`
- `MessageAITests/Integration/SmartNotificationDeepLinkTests.swift`

**Modified Files:**
- `MessageAI/App/AppDelegate.swift` - Add action handlers, deep link handling
- `functions/src/analyzeForNotification.ts` - Add FCM sending, quiet hours check
- `MessageAI/Presentation/Views/Chat/ChatView.swift` - Handle deep link, highlight message
- `MessageAI/Presentation/ViewModels/NavigationState.swift` - Add deep link navigation

### Key Technical Decisions

**1. FCM Payload Structure:**
```typescript
// In analyzeForNotification Cloud Function
const fcmPayload = {
  notification: {
    title: "MessageAI",
    body: notificationText, // AI-generated text from Story 6.3
    sound: priority === 'high' ? 'default' : undefined,
    badge: unreadCount.toString(),
    threadId: conversationId // For grouping
  },
  data: {
    conversationId: conversationId,
    messageId: messageId,
    priority: priority,
    type: "smart_notification"
  },
  apns: {
    payload: {
      aps: {
        category: "SMART_NOTIFICATION_CATEGORY",
        contentAvailable: true,
        mutableContent: true
      }
    },
    fcmOptions: {
      imageUrl: senderAvatarUrl // Sender's profile image
    }
  },
  token: userFcmToken
};

await admin.messaging().send(fcmPayload);
```

**2. Notification Actions Setup:**
```swift
// AppDelegate.swift
func setupSmartNotificationActions() {
    // Feedback actions (Story 6.5)
    let helpfulAction = UNNotificationAction(
        identifier: "HELPFUL_ACTION",
        title: "üëç Helpful",
        options: []
    )

    let notHelpfulAction = UNNotificationAction(
        identifier: "NOT_HELPFUL_ACTION",
        title: "üëé Not Helpful",
        options: []
    )

    // Quick reply action
    let replyAction = UNTextInputNotificationAction(
        identifier: "REPLY_ACTION",
        title: "Reply",
        options: [],
        textInputButtonTitle: "Send",
        textInputPlaceholder: "Type a message..."
    )

    // Mark as read action
    let markReadAction = UNNotificationAction(
        identifier: "MARK_READ_ACTION",
        title: "Mark Read",
        options: [.destructive]
    )

    let smartNotificationCategory = UNNotificationCategory(
        identifier: "SMART_NOTIFICATION_CATEGORY",
        actions: [replyAction, markReadAction, helpfulAction, notHelpfulAction],
        intentIdentifiers: [],
        options: [.customDismissAction]
    )

    UNUserNotificationCenter.current().setNotificationCategories([smartNotificationCategory])
}
```

**3. Action Handlers:**
```swift
// AppDelegate.swift
func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    didReceive response: UNNotificationResponse,
    withCompletionHandler completionHandler: @escaping () -> Void
) {
    let userInfo = response.notification.request.content.userInfo
    let conversationId = userInfo["conversationId"] as? String ?? ""
    let messageId = userInfo["messageId"] as? String ?? ""

    switch response.actionIdentifier {
    case "REPLY_ACTION":
        guard let textResponse = response as? UNTextInputNotificationResponse else {
            completionHandler()
            return
        }
        handleQuickReply(conversationId: conversationId, text: textResponse.userText)

    case "MARK_READ_ACTION":
        handleMarkAsRead(conversationId: conversationId, messageId: messageId)

    case "HELPFUL_ACTION":
        submitFeedback(conversationId: conversationId, messageId: messageId, feedback: "helpful")

    case "NOT_HELPFUL_ACTION":
        submitFeedback(conversationId: conversationId, messageId: messageId, feedback: "not_helpful")

    case UNNotificationDefaultActionIdentifier:
        // User tapped notification body - deep link
        handleDeepLink(conversationId: conversationId, messageId: messageId)

    default:
        break
    }

    completionHandler()
}

private func handleQuickReply(conversationId: String, text: String) {
    Task {
        let messageRepository = DIContainer.shared.makeMessageRepository()
        let currentUserId = DIContainer.shared.currentUserId

        let message = Message(
            id: UUID().uuidString,
            conversationId: conversationId,
            senderId: currentUserId,
            text: text,
            timestamp: Date(),
            status: .sending,
            isEdited: false,
            isDeleted: false,
            editHistory: nil,
            readBy: [currentUserId]
        )

        try await messageRepository.sendMessage(message)

        // Show confirmation
        UNUserNotificationCenter.current().add(
            UNNotificationRequest(
                identifier: UUID().uuidString,
                content: {
                    let content = UNMutableNotificationContent()
                    content.title = "Message Sent"
                    content.body = "Your reply was sent successfully"
                    return content
                }(),
                trigger: nil
            )
        )
    }
}

private func handleMarkAsRead(conversationId: String, messageId: String) {
    Task {
        let messageRepository = DIContainer.shared.makeMessageRepository()
        try await messageRepository.markAsRead(messageId: messageId, userId: DIContainer.shared.currentUserId)

        // Remove notification from notification center
        UNUserNotificationCenter.current().removeDeliveredNotifications(withIdentifiers: [messageId])
    }
}

private func handleDeepLink(conversationId: String, messageId: String) {
    NotificationCenter.default.post(
        name: .openConversation,
        object: nil,
        userInfo: [
            "conversationId": conversationId,
            "messageId": messageId
        ]
    )
}
```

**4. Deep Link Handling in ChatView:**
```swift
// ChatView.swift
@State private var highlightedMessageId: String?

var body: some View {
    ScrollViewReader { scrollProxy in
        messageList
            .onAppear {
                // Handle deep link
                if let targetMessageId = viewModel.targetMessageId {
                    scrollToMessage(targetMessageId, proxy: scrollProxy)
                    highlightedMessageId = targetMessageId
                    viewModel.targetMessageId = nil // Clear after handling
                }
            }
            .onReceive(NotificationCenter.default.publisher(for: .scrollToMessage)) { notification in
                if let messageId = notification.userInfo?["messageId"] as? String {
                    scrollToMessage(messageId, proxy: scrollProxy)
                    highlightedMessageId = messageId
                }
            }
    }
}

private func scrollToMessage(_ messageId: String, proxy: ScrollViewProxy) {
    withAnimation {
        proxy.scrollTo(messageId, anchor: .center)
    }
}

// In message row view
MessageRowView(message: message)
    .id(message.id)
    .modifier(MessageHighlightModifier(isHighlighted: highlightedMessageId == message.id))
```

**5. Message Highlight Modifier:**
```swift
struct MessageHighlightModifier: ViewModifier {
    let isHighlighted: Bool
    @State private var opacity: Double = 0

    func body(content: Content) -> some View {
        content
            .background(
                Color.yellow
                    .opacity(opacity)
                    .animation(.easeInOut(duration: 0.5), value: opacity)
            )
            .onAppear {
                if isHighlighted {
                    animateHighlight()
                }
            }
    }

    private func animateHighlight() {
        // Flash on
        withAnimation(.easeIn(duration: 0.3)) {
            opacity = 0.3
        }

        // Hold
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.3) {
            // Fade out
            withAnimation(.easeOut(duration: 0.5)) {
                opacity = 0
            }
        }
    }
}
```

**6. Active Conversation Tracking:**
```swift
// ChatView.swift
.onAppear {
    // Update user activity in Firestore
    Task {
        try await updateUserActivity(conversationId: conversationId, isActive: true)
    }
}
.onDisappear {
    // Clear active conversation
    Task {
        try await updateUserActivity(conversationId: nil, isActive: false)
    }
}

private func updateUserActivity(conversationId: String?, isActive: Bool) async throws {
    let db = Firestore.firestore()
    let userId = DIContainer.shared.currentUserId

    if isActive, let conversationId = conversationId {
        try await db.collection("user_activity").document(userId).setData([
            "userId": userId,
            "activeConversationId": conversationId,
            "timestamp": FieldValue.serverTimestamp()
        ])
    } else {
        try await db.collection("user_activity").document(userId).delete()
    }
}
```

**7. Cloud Function: Active Conversation Check:**
```typescript
// In analyzeForNotification
async function shouldSuppressNotification(userId: string, conversationId: string): Promise<boolean> {
  const userActivity = await db.collection('user_activity').doc(userId).get();

  if (!userActivity.exists) return false;

  const data = userActivity.data()!;
  const activeConversationId = data.activeConversationId;
  const timestamp = data.timestamp.toDate();

  // Check if activity is recent (within last 2 minutes)
  const twoMinutesAgo = new Date(Date.now() - 2 * 60 * 1000);
  if (timestamp < twoMinutesAgo) return false;

  // Suppress if user is viewing this conversation
  return activeConversationId === conversationId;
}
```

**8. Quiet Hours Check:**
```typescript
function isInQuietHours(preferences: NotificationPreferences): boolean {
  const userTimezone = preferences.timezone || 'UTC';
  const now = new Date().toLocaleString('en-US', { timeZone: userTimezone });
  const currentTime = new Date(now);
  const currentHour = currentTime.getHours();
  const currentMinute = currentTime.getMinutes();

  // Parse quiet hours start/end (format: "HH:MM")
  const [startHour, startMinute] = preferences.quietHoursStart.split(':').map(Number);
  const [endHour, endMinute] = preferences.quietHoursEnd.split(':').map(Number);

  const currentMinutes = currentHour * 60 + currentMinute;
  const startMinutes = startHour * 60 + startMinute;
  const endMinutes = endHour * 60 + endMinute;

  // Handle overnight quiet hours (e.g., 22:00 to 08:00)
  if (startMinutes > endMinutes) {
    return currentMinutes >= startMinutes || currentMinutes < endMinutes;
  }

  return currentMinutes >= startMinutes && currentMinutes < endMinutes;
}
```

**9. Rate Limiting:**
```typescript
async function checkRateLimit(userId: string, maxPerHour: number): Promise<boolean> {
  const now = Date.now();
  const oneHourAgo = now - 60 * 60 * 1000;

  const rateLimitDoc = await db.collection('rate_limits').doc(userId).get();

  if (!rateLimitDoc.exists) {
    // Initialize
    await db.collection('rate_limits').doc(userId).set({
      userId,
      count: 1,
      resetAt: new Date(now + 60 * 60 * 1000)
    });
    return true;
  }

  const data = rateLimitDoc.data()!;
  const resetAt = data.resetAt.toDate();

  // Check if reset time passed
  if (resetAt < new Date()) {
    // Reset counter
    await db.collection('rate_limits').doc(userId).set({
      userId,
      count: 1,
      resetAt: new Date(now + 60 * 60 * 1000)
    });
    return true;
  }

  // Check if under limit
  if (data.count < maxPerHour) {
    // Increment counter
    await db.collection('rate_limits').doc(userId).update({
      count: admin.firestore.FieldValue.increment(1)
    });
    return true;
  }

  // Rate limit exceeded
  return false;
}
```

### Testing Standards

**Test File Location:**
- Integration tests: `MessageAITests/Integration/SmartNotificationDeepLinkTests.swift`
- UI tests: `MessageAIUITests/Notifications/SmartNotificationUITests.swift`

**Testing Frameworks:**
- XCTest for integration tests
- XCUITest for UI tests
- Firebase Emulator for Cloud Function testing

**Test Coverage Requirements:**
- Deep link handling: 90%+ (critical path)
- Notification action handlers: 80%+
- Active conversation suppression: 90%+

**Testing Patterns:**
```swift
class SmartNotificationDeepLinkTests: XCTestCase {
    func testTapNotificationNavigatesToConversation() throws {
        // Given: App is in background
        // When: User taps smart notification
        let notification = simulateNotification(
            conversationId: "conv123",
            messageId: "msg456"
        )

        handleNotificationTap(notification)

        // Then: App navigates to conversation
        XCTAssertEqual(navigationState.selectedConversationId, "conv123")
    }

    func testMessageHighlightedOnDeepLink() async throws {
        // Given: User taps notification
        let messageId = "msg456"

        // When: Deep link handled
        await openConversation(conversationId: "conv123", targetMessageId: messageId)

        // Then: Message is scrolled to and highlighted
        let chatView = try XCTUnwrap(app.currentChatView)
        XCTAssertTrue(chatView.isMessageHighlighted(messageId))
    }

    func testActiveConversationSuppressesNotification() async throws {
        // Given: User is viewing conversation
        await openConversation(conversationId: "conv123")

        // When: New message arrives
        await sendMessage(conversationId: "conv123", text: "Test message")

        // Then: No notification sent
        let notifications = await getDeliveredNotifications()
        XCTAssertEqual(notifications.count, 0)
    }

    func testQuietHoursSuppressMediumPriority() async throws {
        // Given: Current time is in quiet hours (22:00 - 08:00)
        mockCurrentTime(hour: 23, minute: 30)

        // When: Medium priority notification triggered
        let decision = await analyzeNotification(conversationId: "conv123", priority: "medium")

        // Then: Notification suppressed
        XCTAssertFalse(decision.wasDelivered)
        XCTAssertTrue(decision.suppressReason.contains("quiet hours"))
    }

    func testHighPriorityBypassesQuietHours() async throws {
        // Given: Current time is in quiet hours
        mockCurrentTime(hour: 23, minute: 30)

        // When: High priority notification triggered
        let decision = await analyzeNotification(conversationId: "conv123", priority: "high")

        // Then: Notification delivered
        XCTAssertTrue(decision.wasDelivered)
    }
}
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
