# Story 6.5: Feedback Loop, Analytics & Continuous Improvement

## Status

**Draft**

---

## Story

**As a** user,
**I want** to provide feedback on notification decisions,
**so that** the AI learns my preferences and improves over time.

---

## Acceptance Criteria

**Notification Feedback UI:**
1. When notification delivered, notification includes action buttons: "üëç Helpful" | "üëé Not Helpful"
2. iOS: Use UNNotificationAction for interactive notifications
3. Tap feedback button sends feedback to Cloud Function: `submitNotificationFeedback`
4. Feedback stored in Firestore: `notification_feedback` collection
5. Schema: `{ userId, conversationId, messageId, decision: {shouldNotify, reason}, feedback: "helpful" | "not_helpful", timestamp }`

**In-App Feedback:**
6. Settings section: "Notification History" shows last 20 notifications
7. Each entry shows: conversation name, notification text, timestamp, AI reasoning
8. User can provide feedback retroactively: thumbs up/down on each entry
9. Feedback syncs to Firestore immediately

**Feedback Analytics Dashboard (Cloud Function):**
10. Cloud Function: `generateNotificationAnalytics(userId: String)` (admin only)
11. Returns: `{ totalNotifications, helpfulCount, notHelpfulCount, accuracy: helpfulCount/total, commonFalsePositives: [...], commonFalseNegatives: [...] }`
12. False positives: Notified but marked "not helpful"
13. False negatives: Didn't notify but user manually opened conversation within 5 minutes (inferred miss)

**Learning from Feedback:**
14. Cloud Function: `updateUserNotificationProfile(userId: String)`
    - Deployed as scheduled function (Cloud Scheduler)
    - Runs every Monday at 00:00 UTC
    - Iterates through all users with notification feedback
    - For demo: Also exposed as callable function for manual testing
15. Analyzes user's feedback history (last 30 days)
16. Updates user profile: `users/{userId}/ai_notification_profile`
17. Profile includes: `{ preferredNotificationRate: "high" | "medium" | "low", learnedKeywords: [String], suppressedTopics: [String] }`
18. LLM prompt in Story 6.3 includes user profile for personalization

**Prompt Refinement:**
19. User profile injected into LLM system prompt: "User prefers fewer notifications (medium rate). User finds these topics important: [list]. User doesn't want notifications about: [list]."
20. Learned keywords added to priority detection logic
21. Suppressed topics reduce notification likelihood

**False Negative Detection (Optional for MVP):**
22. Track when user opens conversation within 5 minutes of unread message arrival
23. Log to Firestore: `false_negatives` collection with userId, conversationId, timestamp
24. NO AUTOMATIC PROFILE ADJUSTMENT - just log for analytics visibility
25. Future work: Could be used to adjust user profile in production (not required for bootcamp demo)

**Analytics Logging:**
26. Every notification decision logged to Firestore: `notification_decisions` collection
27. Schema: `{ userId, conversationId, timestamp, decision, aiReasoning, wasDelivered: Bool, userFeedback: String? }`
28. Used for debugging and improving prompts

**Cost Tracking (Optional for MVP):**
29. Log AI API costs per analysis: `ai_usage_logs` collection
30. Schema: `{ userId, timestamp, feature: "smart_notification", tokensUsed, estimatedCost }`
31. Admin dashboard: View total costs, cost per user, cost trends
32. Note: Not critical for bootcamp demo, but useful for production monitoring

**Performance Metrics:**
33. Track analysis latency: p50, p95, p99
34. Track cache hit rate (target: 60%+ cache hits, 75%+ with improved caching from Story 6.3)
35. Track fallback usage rate (target: < 5% fallback due to errors)

**Testing:**
36. Unit test: Feedback submission stores correct data
37. Integration test: Feedback affects future notifications (learned preferences applied)
38. Integration test: False negative detection logs correctly (if implemented)
39. Integration test: Analytics function returns accurate statistics
40. UI test: Notification history displays correctly
41. UI test: Feedback buttons work in notifications and history

---

## Tasks / Subtasks

- [ ] Add feedback actions to push notifications (AC: 1-2)
  - [ ] Update FCM notification payload to include action buttons
  - [ ] Define UNNotificationAction categories: "NOTIFICATION_FEEDBACK"
  - [ ] Add actions: "HELPFUL_ACTION", "NOT_HELPFUL_ACTION"
  - [ ] Implement action handlers in AppDelegate or NotificationCenter observer

- [ ] Create submitNotificationFeedback Cloud Function (AC: 3-5)
  - [ ] Create `functions/src/submitNotificationFeedback.ts`
  - [ ] Validate input: userId, conversationId, messageId, feedback
  - [ ] Store feedback in Firestore `notification_feedback` collection
  - [ ] Return success response

- [ ] Implement notification history UI (AC: 6-9)
  - [ ] Create `NotificationHistoryView.swift` in Presentation/Views/Settings
  - [ ] Create `NotificationHistoryViewModel` with @Published history list
  - [ ] Fetch last 20 decisions from `notification_decisions` collection
  - [ ] Display: conversation name, notification text, timestamp, AI reasoning
  - [ ] Add thumbs up/down buttons for retroactive feedback
  - [ ] Call `submitNotificationFeedback` on button tap

- [ ] Create generateNotificationAnalytics Cloud Function (AC: 10-13)
  - [ ] Create `functions/src/generateNotificationAnalytics.ts`
  - [ ] Query `notification_feedback` collection for user
  - [ ] Calculate: total, helpful, not helpful, accuracy rate
  - [ ] Identify false positives: shouldNotify=true + feedback=not_helpful
  - [ ] Identify false negatives: conversation opened within 5 min, no notification sent
  - [ ] Aggregate common patterns (which conversation types get false feedback)
  - [ ] Return analytics JSON

- [ ] Implement updateUserNotificationProfile Cloud Function (AC: 14-18)
  - [ ] Create `functions/src/updateUserNotificationProfile.ts`
  - [ ] Schedule to run weekly (Cloud Scheduler or Pub/Sub)
  - [ ] Load user's feedback history (last 30 days)
  - [ ] Analyze feedback patterns:
    - If 80%+ helpful: `preferredNotificationRate = "high"`
    - If 50-80% helpful: `preferredNotificationRate = "medium"`
    - If < 50% helpful: `preferredNotificationRate = "low"`
  - [ ] Extract learned keywords from helpful notifications
  - [ ] Extract suppressed topics from not-helpful notifications
  - [ ] Save to `users/{userId}/ai_notification_profile`

- [ ] Integrate user profile into LLM prompt (AC: 19-21)
  - [ ] Update `notification-analysis-prompt.ts` to include user profile
  - [ ] Add section: "User's learned preferences: [profile]"
  - [ ] Adjust prompt: "User prefers [rate] notification frequency"
  - [ ] Include learned keywords and suppressed topics

- [ ] (OPTIONAL) Implement false negative detection (AC: 22-25)
  - [ ] Create background job: Monitor user activity in conversations
  - [ ] Track: User opens conversation within 5 minutes of unread message
  - [ ] Query: Was notification suppressed for this conversation?
  - [ ] Log to Firestore: `false_negatives` collection
  - [ ] NO automatic profile adjustment - just for analytics
  - [ ] Note: Can skip for MVP, focus on explicit feedback instead

- [ ] Create notification decisions logging (AC: 26-28)
  - [ ] Update `analyzeForNotification` to log all decisions
  - [ ] Store in Firestore: `notification_decisions` collection
  - [ ] Include: userId, conversationId, timestamp, decision, aiReasoning, wasDelivered
  - [ ] Add index: userId + timestamp (for fast queries)

- [ ] Implement cost tracking (AC: 29-31)
  - [ ] Update OpenAI service wrapper to log token usage
  - [ ] Store in Firestore: `ai_usage_logs` collection
  - [ ] Calculate estimated cost: inputTokens * $0.03/1K + outputTokens * $0.06/1K
  - [ ] Create admin Cloud Function: `getAIUsageReport(startDate, endDate)`
  - [ ] Return: total cost, cost per user, cost breakdown by feature

- [ ] Implement performance metrics (AC: 32-34)
  - [ ] Track analysis latency in Cloud Function
  - [ ] Log to Firestore: `performance_metrics` collection
  - [ ] Calculate p50, p95, p99 latencies
  - [ ] Track cache hit rate: cacheHits / totalAnalyses
  - [ ] Track fallback rate: fallbackUsed / totalAnalyses
  - [ ] Create admin dashboard Cloud Function: `getPerformanceMetrics()`

- [ ] Write unit tests (AC: 35)
  - [ ] Test: Feedback submission stores correct data
  - [ ] Test: Analytics calculation is accurate
  - [ ] Test: User profile update logic works correctly
  - [ ] Test: False negative detection identifies patterns

- [ ] Write integration tests (AC: 36-38)
  - [ ] Test: Submit feedback, verify stored in Firestore
  - [ ] Test: User profile affects future notification decisions
  - [ ] Test: False negative detection logs correctly
  - [ ] Test: Analytics function returns accurate stats

- [ ] Write UI tests (AC: 39-40)
  - [ ] Test: Notification history displays last 20 decisions
  - [ ] Test: Thumbs up/down buttons submit feedback
  - [ ] Test: Feedback buttons in push notifications work

---

## Dev Notes

### Architecture Context

**Feedback Loop Flow:**
```
User receives notification
  ‚Üì
User taps "üëç Helpful" or "üëé Not Helpful"
  ‚Üì
submitNotificationFeedback Cloud Function
  ‚Üì
Store in notification_feedback collection
  ‚Üì
Weekly: updateUserNotificationProfile analyzes feedback
  ‚Üì
Update ai_notification_profile with learned preferences
  ‚Üì
Future notifications use updated profile in LLM prompt
```

**Analytics Pipeline:**
```
Every notification decision ‚Üí notification_decisions collection
Every feedback submission ‚Üí notification_feedback collection
Every AI API call ‚Üí ai_usage_logs collection
Every analysis ‚Üí performance_metrics collection

Admin queries:
- generateNotificationAnalytics(userId) ‚Üí User-specific stats
- getAIUsageReport(startDate, endDate) ‚Üí Cost breakdown
- getPerformanceMetrics() ‚Üí Latency, cache hit rate, fallback rate
```

### Relevant Source Tree

**New Files:**
- `functions/src/submitNotificationFeedback.ts`
- `functions/src/generateNotificationAnalytics.ts`
- `functions/src/updateUserNotificationProfile.ts`
- `functions/src/admin/getAIUsageReport.ts`
- `functions/src/admin/getPerformanceMetrics.ts`
- `MessageAI/Presentation/Views/Settings/NotificationHistoryView.swift`
- `MessageAI/Presentation/ViewModels/NotificationHistoryViewModel.swift`
- `MessageAITests/Presentation/ViewModels/NotificationHistoryViewModelTests.swift`

**Modified Files:**
- `MessageAI/App/AppDelegate.swift` - Add notification action handlers
- `functions/src/analyzeForNotification.ts` - Add decision logging, cost tracking
- `functions/src/prompts/notification-analysis-prompt.ts` - Include user profile

### Key Technical Decisions

**1. Interactive Notification Actions:**
```swift
// AppDelegate.swift
func setupNotificationActions() {
    let helpfulAction = UNNotificationAction(
        identifier: "HELPFUL_ACTION",
        title: "üëç Helpful",
        options: []
    )

    let notHelpfulAction = UNNotificationAction(
        identifier: "NOT_HELPFUL_ACTION",
        title: "üëé Not Helpful",
        options: []
    )

    let feedbackCategory = UNNotificationCategory(
        identifier: "NOTIFICATION_FEEDBACK",
        actions: [helpfulAction, notHelpfulAction],
        intentIdentifiers: [],
        options: []
    )

    UNUserNotificationCenter.current().setNotificationCategories([feedbackCategory])
}

// Handle action tap
func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    didReceive response: UNNotificationResponse,
    withCompletionHandler completionHandler: @escaping () -> Void
) {
    let userInfo = response.notification.request.content.userInfo

    switch response.actionIdentifier {
    case "HELPFUL_ACTION":
        submitFeedback(userInfo: userInfo, feedback: "helpful")
    case "NOT_HELPFUL_ACTION":
        submitFeedback(userInfo: userInfo, feedback: "not_helpful")
    default:
        break
    }

    completionHandler()
}
```

**2. Notification History ViewModel:**
```swift
@MainActor
class NotificationHistoryViewModel: ObservableObject {
    @Published var history: [NotificationHistoryEntry] = []
    @Published var isLoading = false

    private let repository: NotificationDecisionRepositoryProtocol

    func loadHistory() async {
        isLoading = true
        do {
            history = try await repository.getRecentDecisions(limit: 20)
        } catch {
            print("Error loading history: \(error)")
        }
        isLoading = false
    }

    func submitFeedback(for entry: NotificationHistoryEntry, feedback: String) async {
        do {
            try await repository.submitFeedback(
                conversationId: entry.conversationId,
                messageId: entry.messageId,
                feedback: feedback
            )

            // Update local entry
            if let index = history.firstIndex(where: { $0.id == entry.id }) {
                history[index].userFeedback = feedback
            }
        } catch {
            print("Error submitting feedback: \(error)")
        }
    }
}

struct NotificationHistoryEntry: Identifiable {
    let id: String
    let conversationId: String
    let conversationName: String
    let messageId: String
    let notificationText: String
    let aiReasoning: String
    let timestamp: Date
    let decision: NotificationDecision
    var userFeedback: String?
}
```

**3. User Notification Profile Schema:**
```typescript
// users/{userId}/ai_notification_profile
interface NotificationProfile {
  userId: string;
  preferredNotificationRate: "high" | "medium" | "low"; // Based on feedback accuracy
  learnedKeywords: string[]; // Extracted from helpful notifications
  suppressedTopics: string[]; // Extracted from not-helpful notifications
  updatedAt: Timestamp;
  feedbackCount: number;
  accuracy: number; // helpfulCount / totalFeedback
}
```

**4. Profile Update Logic:**
```typescript
export const updateUserNotificationProfile = functions
  .pubsub.schedule('every monday 00:00')
  .onRun(async (context) => {
    const users = await db.collection('users').get();

    for (const userDoc of users.docs) {
      const userId = userDoc.id;

      // Get feedback from last 30 days
      const feedbackSnapshot = await db.collection('notification_feedback')
        .where('userId', '==', userId)
        .where('timestamp', '>', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))
        .get();

      if (feedbackSnapshot.empty) continue;

      const feedback = feedbackSnapshot.docs.map(doc => doc.data());
      const helpfulCount = feedback.filter(f => f.feedback === 'helpful').length;
      const accuracy = helpfulCount / feedback.length;

      // Determine preferred rate
      let preferredRate: 'high' | 'medium' | 'low';
      if (accuracy >= 0.8) {
        preferredRate = 'high'; // User likes most notifications
      } else if (accuracy >= 0.5) {
        preferredRate = 'medium';
      } else {
        preferredRate = 'low'; // User finds most notifications unhelpful
      }

      // Extract learned keywords from helpful notifications
      const helpfulNotifications = feedback.filter(f => f.feedback === 'helpful');
      const learnedKeywords = extractCommonKeywords(helpfulNotifications);

      // Extract suppressed topics from not-helpful notifications
      const notHelpfulNotifications = feedback.filter(f => f.feedback === 'not_helpful');
      const suppressedTopics = extractCommonTopics(notHelpfulNotifications);

      // Update profile
      await db.collection('users').doc(userId)
        .collection('ai_notification_profile')
        .doc('profile')
        .set({
          userId,
          preferredNotificationRate: preferredRate,
          learnedKeywords,
          suppressedTopics,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          feedbackCount: feedback.length,
          accuracy
        });
    }
  });
```

**5. LLM Prompt with User Profile:**
```typescript
function buildPromptWithProfile(
  messages: Message[],
  userContext: UserContext,
  userProfile: NotificationProfile
): string {
  const rateInstruction = {
    high: "User appreciates frequent notifications. Be more liberal in notification decisions.",
    medium: "User prefers moderate notification frequency. Balance importance vs frequency.",
    low: "User dislikes frequent notifications. Only notify for critical messages."
  }[userProfile.preferredNotificationRate];

  return `You are a notification assistant for remote team professionals.

USER'S LEARNED PREFERENCES:
- Notification frequency: ${userProfile.preferredNotificationRate}
- ${rateInstruction}
- User finds these topics important: ${userProfile.learnedKeywords.join(', ')}
- User doesn't want notifications about: ${userProfile.suppressedTopics.join(', ')}

${/* Rest of prompt */}`;
}
```

**6. False Negative Detection:**
```typescript
// Triggered when user opens conversation
export const detectFalseNegative = functions.firestore
  .document('user_activity/{activityId}')
  .onCreate(async (snap, context) => {
    const activity = snap.data();
    const { userId, conversationId, timestamp } = activity;

    // Check if there were recent messages (within 5 minutes)
    const fiveMinutesAgo = new Date(timestamp.toMillis() - 5 * 60 * 1000);
    const recentMessages = await db.collection('messages')
      .where('conversationId', '==', conversationId)
      .where('timestamp', '>', fiveMinutesAgo)
      .get();

    if (recentMessages.empty) return;

    // Check if notification was suppressed
    const latestMessage = recentMessages.docs[0];
    const decision = await db.collection('notification_decisions')
      .where('userId', '==', userId)
      .where('conversationId', '==', conversationId)
      .where('messageId', '==', latestMessage.id)
      .get();

    if (decision.empty || decision.docs[0].data().decision.shouldNotify) {
      return; // Notification was sent or no decision logged
    }

    // Log false negative
    await db.collection('false_negatives').add({
      userId,
      conversationId,
      messageId: latestMessage.id,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      detectedAt: timestamp
    });

    // Check for pattern (3+ false negatives in this conversation)
    const falseNegativesCount = await db.collection('false_negatives')
      .where('userId', '==', userId)
      .where('conversationId', '==', conversationId)
      .where('timestamp', '>', fiveMinutesAgo)
      .count()
      .get();

    if (falseNegativesCount.data().count >= 3) {
      // Adjust user profile: increase sensitivity for this conversation type
      // Implementation: Add to learnedKeywords or adjust preferredRate
    }
  });
```

**7. Analytics Dashboard:**
```typescript
export const generateNotificationAnalytics = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) throw new HttpsError('unauthenticated', 'Must be logged in');

    const userId = context.auth.uid;

    // Get all feedback
    const feedbackSnapshot = await db.collection('notification_feedback')
      .where('userId', '==', userId)
      .get();

    const feedback = feedbackSnapshot.docs.map(doc => doc.data());
    const helpfulCount = feedback.filter(f => f.feedback === 'helpful').length;
    const notHelpfulCount = feedback.filter(f => f.feedback === 'not_helpful').length;

    // Get false negatives
    const falseNegativesSnapshot = await db.collection('false_negatives')
      .where('userId', '==', userId)
      .get();

    return {
      totalNotifications: feedback.length,
      helpfulCount,
      notHelpfulCount,
      accuracy: feedback.length > 0 ? helpfulCount / feedback.length : 0,
      falseNegatives: falseNegativesSnapshot.size,
      commonFalsePositives: identifyCommonPatterns(
        feedback.filter(f => f.feedback === 'not_helpful')
      ),
      commonFalseNegatives: identifyCommonPatterns(
        falseNegativesSnapshot.docs.map(doc => doc.data())
      )
    };
  }
);
```

### Testing Standards

**Test File Location:**
- Unit tests: `functions/test/updateUserNotificationProfile.test.ts`
- Integration tests: `MessageAITests/Integration/FeedbackLoopIntegrationTests.swift`
- UI tests: `MessageAIUITests/Settings/NotificationHistoryUITests.swift`

**Testing Frameworks:**
- Jest for Cloud Functions
- XCTest for iOS integration tests
- Firebase Emulator for end-to-end testing

**Test Coverage Requirements:**
- Feedback submission: 90%+ (critical path)
- Profile update logic: 80%+
- Analytics calculations: 90%+

**Testing Patterns:**
```swift
class FeedbackLoopIntegrationTests: XCTestCase {
    func testFeedbackAffectsFutureNotifications() async throws {
        // Given: User submits "not helpful" feedback for general chat
        await submitFeedback(conversationId: "conv1", feedback: "not_helpful")

        // When: Update user profile (trigger Cloud Function)
        await updateUserProfile(userId: "user123")

        // Then: Next notification for similar chat is suppressed
        let decision = await analyzeConversation(conversationId: "conv2")
        XCTAssertFalse(decision.shouldNotify)
        XCTAssertTrue(decision.reason.contains("user profile"))
    }

    func testFalseNegativeDetection() async throws {
        // Given: User opens conversation within 5 minutes of message
        let messageTime = Date()
        await sendMessage(conversationId: "conv1", timestamp: messageTime)

        // When: User opens conversation 2 minutes later
        await openConversation(conversationId: "conv1", timestamp: messageTime.addingTimeInterval(120))

        // Then: False negative logged
        let falseNegatives = try await db.collection("false_negatives")
            .whereField("conversationId", isEqualTo: "conv1")
            .getDocuments()

        XCTAssertEqual(falseNegatives.count, 1)
    }
}
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
