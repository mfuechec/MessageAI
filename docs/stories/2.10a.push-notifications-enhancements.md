# Story 2.10a: Push Notification Enhancements (Edge Cases & Polish)

## Status

**Draft** (Ready for PO Review)

---

## Story

**As a** user,
**I want** push notifications to work correctly in edge case scenarios,
**so that** I have a reliable notification experience across account switching, permission changes, and network issues.

---

## Context

Story 2.10 implemented core push notification functionality successfully. During SM review, 5 edge cases and architectural improvements were identified that should be addressed for production quality:

1. **Account Switching**: FCM tokens persist across sign-outs, causing cross-user notification leakage
2. **Static State Management**: Global static variable creates testing issues and persists across user sessions
3. **Badge Count Clarity**: Implicit reset behavior not documented in AC
4. **Permission Re-Request**: No way for users to enable notifications after initial denial
5. **Deep Link Edge Case**: Tapping notification when conversation not loaded fails silently
6. **FCM Token Save Reliability**: No retry if token save to Firestore fails

**This story addresses these gaps as enhancements to Story 2.10.**

---

## Acceptance Criteria

### Account Switching & Cleanup (AC 1-4)

1. When user signs out, FCM token is removed from their Firestore user document
2. When user signs out, all notification-related static state is cleared
3. When new user signs in on same device, old user's FCM token is not present
4. New user's FCM token is registered correctly after sign-in

### Notification State Management (AC 5-7)

5. Replace static `ChatViewModel.currentlyViewingConversationId` with `AppState.shared.currentlyViewingConversationId`
6. AppState clears all state on sign-out (viewing conversation, current user)
7. AppState is @MainActor and thread-safe

### Badge Count Behavior (AC 8-10)

8. Badge count increments when new unread messages arrive
9. Badge count decrements when messages are marked as read
10. Badge count resets to 0 when all conversations have no unread messages

### Permission Re-Request Flow (AC 11-13)

11. If user denies notification permissions, show in-app banner: "Enable notifications in Settings to stay updated"
12. Banner includes "Open Settings" button that deep links to iOS Settings app
13. Permission status checked on app launch and banner shown/hidden accordingly

### Deep Link Reliability (AC 14-16)

14. When user taps notification and conversation not loaded yet, app fetches conversation from Firestore
15. ChatView opens after conversation fetch completes (< 2 seconds)
16. If conversation fetch fails (deleted conversation), show error: "This conversation is no longer available"

### FCM Token Save Retry (AC 17-19)

17. If FCM token save to Firestore fails, retry up to 3 times with exponential backoff (1s, 2s, 4s)
18. After 3 failed attempts, log error but don't crash app
19. On next app launch, token save is retried

### Testing & Validation (AC 20-22)

20. Unit test: `testSignOutClearsFCMToken` - Verify token removed from Firestore
21. Unit test: `testAppStateClearsOnSignOut` - Verify static state reset
22. Manual test: Sign out User A, sign in User B, verify User A doesn't receive notifications

---

## What's Already Done (Story 2.10)

Story 2.10 implemented:
- ‚úÖ FCM token registration on app launch
- ‚úÖ Notification permissions request
- ‚úÖ Foreground/background notification handling
- ‚úÖ Deep linking to conversations
- ‚úÖ Badge count updates
- ‚úÖ Conversation viewing suppression
- ‚úÖ AppDelegate with MessagingDelegate

**What Story 2.10a Adds:**
- üÜï Account switching cleanup
- üÜï AppState pattern replacing static variables
- üÜï Permission re-request UI
- üÜï Deep link fallback (fetch conversation if not loaded)
- üÜï FCM token save retry logic

---

## What's NEW in Story 2.10a

### 1. AppState Pattern (Replaces Static Variables)

**NEW FILE:** `MessageAI/App/AppState.swift`

```swift
import Foundation
import SwiftUI

/// Centralized app-level state (replaces static variables in ViewModels)
@MainActor
class AppState: ObservableObject {
    static let shared = AppState()

    // Currently viewing conversation (for notification suppression)
    @Published var currentlyViewingConversationId: String?

    // Current authenticated user (for cleanup on sign-out)
    @Published var currentUserId: String?

    private init() {}

    /// Clear all state (call on sign-out)
    func clearState() {
        currentlyViewingConversationId = nil
        currentUserId = nil
        print("üßπ AppState cleared")
    }
}
```

---

### 2. Update ChatViewModel to Use AppState

**FILE:** `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift`

**REPLACE:**
```swift
// OLD: Static variable (Story 2.10)
static var currentlyViewingConversationId: String?

func onAppear() {
    ChatViewModel.currentlyViewingConversationId = conversationId
    markMessagesAsRead()
}

func onDisappear() {
    if ChatViewModel.currentlyViewingConversationId == conversationId {
        ChatViewModel.currentlyViewingConversationId = nil
    }
}
```

**WITH:**
```swift
// NEW: AppState pattern (Story 2.10a)
func onAppear() {
    AppState.shared.currentlyViewingConversationId = conversationId
    markMessagesAsRead()
}

func onDisappear() {
    if AppState.shared.currentlyViewingConversationId == conversationId {
        AppState.shared.currentlyViewingConversationId = nil
    }
}
```

---

### 3. Update AppDelegate to Use AppState

**FILE:** `MessageAI/App/MessageAIApp.swift`

**UPDATE AppDelegate.willPresent:**

```swift
func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    willPresent notification: UNNotification,
    withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
) {
    let userInfo = notification.request.content.userInfo

    // Check if user is currently viewing this conversation (using AppState)
    if let conversationId = userInfo["conversationId"] as? String {
        let isViewingConversation = AppState.shared.currentlyViewingConversationId == conversationId

        if isViewingConversation {
            completionHandler([])  // Suppress notification
            return
        }
    }

    completionHandler([.banner, .sound, .badge])
}
```

---

### 4. FCM Token Cleanup on Sign-Out

**FILE:** `MessageAI/Presentation/ViewModels/Auth/AuthViewModel.swift`

**UPDATE signOut() method:**

```swift
func signOut() async throws {
    // Step 1: Clear FCM token from Firestore (prevent cross-user notifications)
    if let userId = currentUserId {
        do {
            try await db.collection("users").document(userId).updateData([
                "fcmToken": FieldValue.delete(),
                "fcmTokenUpdatedAt": FieldValue.delete()
            ])
            print("‚úÖ FCM token removed for user: \(userId)")
        } catch {
            print("‚ö†Ô∏è Failed to remove FCM token: \(error)")
            // Don't block sign-out if this fails
        }
    }

    // Step 2: Clear app state
    await MainActor.run {
        AppState.shared.clearState()
    }

    // Step 3: Sign out from Firebase Auth (existing)
    try Auth.auth().signOut()

    // Step 4: Clear local state (existing)
    currentUser = nil
    isLoading = false
}
```

---

### 5. FCM Token Save with Retry Logic

**FILE:** `MessageAI/App/MessageAIApp.swift`

**REPLACE AppDelegate.saveFCMToken:**

```swift
// OLD: No retry (Story 2.10)
private func saveFCMToken(_ token: String) async {
    guard let userId = Auth.auth().currentUser?.uid else { return }

    let db = Firestore.firestore()

    do {
        try await db.collection("users").document(userId).updateData([
            "fcmToken": token,
            "fcmTokenUpdatedAt": FieldValue.serverTimestamp()
        ])
        print("‚úÖ FCM token saved to Firestore for user: \(userId)")
    } catch {
        print("‚ùå Failed to save FCM token: \(error)")
    }
}
```

**WITH:**

```swift
// NEW: Retry logic (Story 2.10a)
private func saveFCMToken(_ token: String) async {
    guard let userId = Auth.auth().currentUser?.uid else { return }

    let db = Firestore.firestore()
    var retryCount = 0
    let maxRetries = 3

    while retryCount < maxRetries {
        do {
            try await db.collection("users").document(userId).updateData([
                "fcmToken": token,
                "fcmTokenUpdatedAt": FieldValue.serverTimestamp()
            ])
            print("‚úÖ FCM token saved to Firestore for user: \(userId)")
            return  // Success - exit retry loop

        } catch {
            retryCount += 1

            if retryCount < maxRetries {
                // Exponential backoff: 1s, 2s, 4s
                let delay = UInt64(pow(2.0, Double(retryCount - 1)) * 1_000_000_000)
                try? await Task.sleep(nanoseconds: delay)
                print("‚ö†Ô∏è FCM token save failed (attempt \(retryCount)/\(maxRetries)), retrying...")
            } else {
                print("‚ùå Failed to save FCM token after \(maxRetries) attempts: \(error)")
                // Token will be retried on next app launch
            }
        }
    }
}
```

---

### 6. Permission Re-Request Banner

**FILE:** `MessageAI/Presentation/Views/Conversations/ConversationsListView.swift`

**ADD property to ConversationsListViewModel:**

```swift
@Published var notificationPermissionDenied: Bool = false

func checkNotificationPermissionStatus() async {
    let center = UNUserNotificationCenter.current()
    let settings = await center.notificationSettings()

    await MainActor.run {
        notificationPermissionDenied = (settings.authorizationStatus == .denied)
    }
}
```

**ADD banner to ConversationsListView:**

```swift
var body: some View {
    NavigationView {
        VStack(spacing: 0) {
            // NEW: Permission denied banner
            if viewModel.notificationPermissionDenied {
                HStack {
                    Image(systemName: "bell.slash")
                        .foregroundColor(.orange)
                    Text("Enable notifications in Settings to stay updated")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Spacer()
                    Button("Open Settings") {
                        if let url = URL(string: UIApplication.openSettingsURLString) {
                            UIApplication.shared.open(url)
                        }
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(Color.orange.opacity(0.1))
            }

            // Existing conversation list
            // ...
        }
    }
    .task {
        await viewModel.checkNotificationPermissionStatus()
    }
}
```

---

### 7. Deep Link Fallback (Fetch Conversation if Not Loaded)

**FILE:** `MessageAI/Presentation/ViewModels/Conversations/ConversationsListViewModel.swift`

**ADD method:**

```swift
/// Fetch single conversation by ID (for deep linking when not in loaded list)
func fetchConversation(id: String) async throws -> Conversation {
    do {
        let conversation = try await conversationRepository.getConversation(id: id)
        print("‚úÖ Fetched conversation for deep link: \(id)")
        return conversation
    } catch {
        print("‚ùå Failed to fetch conversation \(id): \(error)")
        throw error
    }
}
```

**ADD to ConversationRepositoryProtocol:**

```swift
protocol ConversationRepositoryProtocol {
    // ... existing methods ...

    /// Fetch single conversation by ID (for deep linking)
    func getConversation(id: String) async throws -> Conversation
}
```

**IMPLEMENT in FirebaseConversationRepository:**

```swift
func getConversation(id: String) async throws -> Conversation {
    let snapshot = try await db.collection("conversations").document(id).getDocument()

    guard snapshot.exists else {
        throw RepositoryError.conversationNotFound
    }

    return try snapshot.data(as: Conversation.self)
}
```

**UPDATE ConversationsListView deep link handler:**

```swift
.onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("OpenConversation"))) { notification in
    if let conversationId = notification.userInfo?["conversationId"] as? String {

        // Try to find in loaded conversations first
        if let conversation = viewModel.conversations.first(where: { $0.id == conversationId }) {
            openConversation(conversation)
        } else {
            // Not loaded yet - fetch from Firestore
            Task {
                do {
                    let conversation = try await viewModel.fetchConversation(id: conversationId)
                    await MainActor.run {
                        openConversation(conversation)
                    }
                } catch {
                    await MainActor.run {
                        viewModel.errorMessage = "This conversation is no longer available"
                    }
                }
            }
        }
    }
}
```

---

## Tasks / Subtasks

### Task 1: Create AppState Class (AC: 5-7)
- [ ] 1.1: Create `MessageAI/App/AppState.swift`
- [ ] 1.2: Add `@MainActor` class with `ObservableObject` conformance
- [ ] 1.3: Add `currentlyViewingConversationId: String?` property
- [ ] 1.4: Add `currentUserId: String?` property
- [ ] 1.5: Add `clearState()` method
- [ ] 1.6: Write unit test: `testAppStateSingleton`
- [ ] 1.7: Write unit test: `testAppStateClearState`

### Task 2: Update ChatViewModel to Use AppState (AC: 5-6)
- [ ] 2.1: Remove `static var currentlyViewingConversationId`
- [ ] 2.2: Update `onAppear()` to use `AppState.shared`
- [ ] 2.3: Update `onDisappear()` to use `AppState.shared`
- [ ] 2.4: Update unit tests (replace static var references)

### Task 3: Update AppDelegate to Use AppState (AC: 5-6)
- [ ] 3.1: Update `willPresent notification` to check `AppState.shared.currentlyViewingConversationId`
- [ ] 3.2: Remove old static variable references
- [ ] 3.3: Test notification suppression still works

### Task 4: Add FCM Token Cleanup on Sign-Out (AC: 1-4)
- [ ] 4.1: Update `AuthViewModel.signOut()` to delete fcmToken from Firestore
- [ ] 4.2: Call `AppState.shared.clearState()` in signOut
- [ ] 4.3: Write unit test: `testSignOutClearsFCMToken`
- [ ] 4.4: Write unit test: `testSignOutClearsAppState`
- [ ] 4.5: Manual test: Sign out, verify token removed in Firebase Console

### Task 5: Add FCM Token Save Retry Logic (AC: 17-19)
- [ ] 5.1: Update `AppDelegate.saveFCMToken()` with retry loop
- [ ] 5.2: Add exponential backoff (1s, 2s, 4s delays)
- [ ] 5.3: Log each retry attempt
- [ ] 5.4: Write unit test: `testFCMTokenSaveRetrySuccess`
- [ ] 5.5: Write unit test: `testFCMTokenSaveRetryMaxAttempts`

### Task 6: Add Permission Re-Request Banner (AC: 11-13)
- [ ] 6.1: Add `notificationPermissionDenied` property to ConversationsListViewModel
- [ ] 6.2: Add `checkNotificationPermissionStatus()` method
- [ ] 6.3: Add banner UI to ConversationsListView
- [ ] 6.4: Add "Open Settings" button with deep link
- [ ] 6.5: Call checkNotificationPermissionStatus on view appear
- [ ] 6.6: Write unit test: `testNotificationPermissionDeniedBanner`

### Task 7: Add Deep Link Fallback (AC: 14-16)
- [ ] 7.1: Add `getConversation(id:)` to ConversationRepositoryProtocol
- [ ] 7.2: Implement in FirebaseConversationRepository
- [ ] 7.3: Add `fetchConversation(id:)` to ConversationsListViewModel
- [ ] 7.4: Update deep link handler with fallback logic
- [ ] 7.5: Show error message if conversation not found
- [ ] 7.6: Write unit test: `testDeepLinkFallbackFetchesConversation`
- [ ] 7.7: Write unit test: `testDeepLinkFallbackConversationNotFound`

### Task 8: Update Badge Count Documentation (AC: 8-10)
- [ ] 8.1: Update Story 2.10 AC #11 with explicit behavior
- [ ] 8.2: Add comment in `updateBadgeCount()` method explaining behavior
- [ ] 8.3: Write unit test: `testBadgeCountResetsToZero` (if not already exists)

### Task 9: Manual Testing (AC: 22)
- [ ] 9.1: Test account switching flow (sign out User A, sign in User B)
- [ ] 9.2: Verify User A's FCM token removed from Firestore
- [ ] 9.3: Verify User B's FCM token saved correctly
- [ ] 9.4: Send message to User A, verify User B doesn't receive notification
- [ ] 9.5: Test permission denial banner appears
- [ ] 9.6: Test "Open Settings" button deep links correctly
- [ ] 9.7: Test deep link when conversation not loaded (tap notification immediately after app launch)
- [ ] 9.8: Test deep link to deleted conversation shows error

### Task 10: Regression Testing (AC: 20-21)
- [ ] 10.1: Run story-level tests: `./scripts/test-story.sh AuthViewModelTests`
- [ ] 10.2: Run story-level tests: `./scripts/test-story.sh ChatViewModelTests`
- [ ] 10.3: Run epic-level tests: `./scripts/test-epic.sh 2`
- [ ] 10.4: Verify all Story 2.10 functionality still works

---

## Testing

### Unit Tests Required (8-10 tests)

**AppStateTests.swift (NEW FILE)**
1. `testAppStateSingleton` - Verify shared instance
2. `testAppStateClearState` - Verify clearState() resets properties

**AuthViewModelTests.swift**
3. `testSignOutClearsFCMToken` - Verify Firestore delete called
4. `testSignOutClearsAppState` - Verify AppState.shared.clearState() called

**ConversationsListViewModelTests.swift**
5. `testNotificationPermissionDeniedBanner` - Verify permission status check
6. `testFetchConversation` - Verify repository method called
7. `testDeepLinkFallbackFetchesConversation` - Verify fallback logic
8. `testDeepLinkFallbackConversationNotFound` - Verify error handling

**ChatViewModelTests.swift**
9. `testAppStateTracking` - Update existing test to use AppState instead of static var

**AppDelegateTests.swift (if feasible)**
10. `testFCMTokenSaveRetrySuccess` - Verify retry on first failure
11. `testFCMTokenSaveRetryMaxAttempts` - Verify gives up after 3 attempts

---

### Manual Testing Checklist

#### Test 1: Account Switching FCM Token Cleanup
1. Device A: Sign in as test1@messageai.dev
2. Wait for FCM token registration (check Firebase Console)
3. Device A: Sign out
4. Firebase Console: Verify test1 user doc has NO fcmToken field
5. Device A: Sign in as test2@messageai.dev
6. Wait for FCM token registration
7. Device B: Send message to test1@messageai.dev
8. **Expected (Device A):** NO notification received (User A's token deleted)

#### Test 2: AppState Clears on Sign-Out
1. Device A: Sign in, open Chat with test2
2. Verify AppState.currentlyViewingConversationId = test2's conversation
3. Navigate back to conversations list
4. Sign out
5. **Expected:** AppState.currentlyViewingConversationId = nil
6. **Expected:** No crashes or errors

#### Test 3: Permission Re-Request Banner
1. Fresh app install
2. Sign in, deny notification permissions when prompted
3. Navigate to conversations list
4. **Expected:** Orange banner appears: "Enable notifications in Settings..."
5. Tap "Open Settings" button
6. **Expected:** iOS Settings app opens to MessageAI settings page
7. Enable notifications in Settings
8. Return to app
9. **Expected:** Banner disappears on next app launch

#### Test 4: Deep Link Fallback
1. Device A: Sign in, keep on conversations list (don't load any chats)
2. Device B: Send message to Device A
3. Device A: Tap notification immediately (before conversation list loads)
4. **Expected:** App fetches conversation from Firestore
5. **Expected:** ChatView opens within 2 seconds

#### Test 5: Deep Link to Deleted Conversation
1. User A creates conversation with User B
2. User A deletes conversation (mock in Firebase Console)
3. User B sends notification (via Cloud Function trigger)
4. User A taps notification
5. **Expected:** Error message: "This conversation is no longer available"

#### Test 6: FCM Token Save Retry (Simulated)
1. Enable network throttling or airplane mode
2. Launch app, sign in
3. FCM token received but Firestore save fails
4. **Expected:** Retry log messages appear (attempt 1/3, 2/3, 3/3)
5. Enable network after 2 failed attempts
6. **Expected:** Third attempt succeeds, token saved

---

## Complexity & Time Estimate

**Complexity:** Low-Medium
**Estimated Time:** 2-3 hours
**Risk Level:** Low

**Breakdown:**
- AppState class creation: 30 minutes
- FCM token cleanup on sign-out: 30 minutes
- FCM token save retry logic: 20 minutes
- Permission banner UI: 30 minutes
- Deep link fallback: 40 minutes
- Unit tests: 30 minutes
- Manual testing: 30 minutes

---

## Dependencies

**Blocks:** None (enhancement to completed Story 2.10)
**Blocked By:** Story 2.10 must be completed (currently Done)
**External:** None

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-10-22 | 1.0 | Story created - Push Notification Enhancements | Bob (SM) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

---

## QA Results

*This section will be populated by QA agent after implementation.*
