# Story 2.6: Typing Indicators

## Status

**Approved**

---

## Story

**As a** user,  
**I want** to see when someone is typing in a conversation,  
**so that** I know to wait for their response.

---

## Acceptance Criteria

1. Typing indicator appears below last message when participant is actively typing
2. Indicator shows: "[Name] is typing..." (one-on-one) or "[Name], [Name] are typing..." (group)
3. Firestore document tracks typing state per user per conversation (ephemeral data)
4. Typing state set to true when user types, false after 3 seconds of inactivity or on send
5. Real-time updates: Typing indicators appear within 500ms for recipients
6. Typing state cleared when user leaves chat view
7. Performance: Typing updates throttled (max 1 update per second) to reduce Firestore writes
8. Reliability: Typing state automatically cleared after timeout (prevents stuck "is typing")
9. MessageKit integrated typing indicator UI used (if available) or custom SwiftUI component
10. Unit tests for typing state management logic
11. Integration test: User A types, User B sees typing indicator within 1 second
12. Performance test: Typing updates don't cause lag in message composition
13. Regression test: Message sending, editing, and real-time updates still performant

---

## Previous Story Context (Story 2.5 Completion)

### Key Learnings from Story 2.5

**Real-Time State Management:**
- Firestore listener patterns for automatic UI updates
- Efficient array manipulation (add to readBy without full refetch)
- Batch writes for performance when updating multiple documents
- Optimistic UI patterns that don't require rollback (best-effort updates)

**ChatViewModel Patterns:**
- Lifecycle methods (onAppear/onDisappear) for tracking view state
- Repository protocol extensions for new functionality
- Published properties for SwiftUI binding
- Error handling with user-friendly messages

**Performance Considerations:**
- Read receipts showed importance of minimizing Firestore writes
- Batch updates when possible (multiple messages marked as read in one batch)
- Status transition validation prevents invalid state changes

**UI Integration:**
- MessageKit delegates for custom UI elements
- SwiftUI overlays for modals and detail views
- Real-time updates via Combine publishers

### Impact on Story 2.6

Story 2.6 will use similar patterns:
- Throttle typing updates to reduce Firestore writes (max 1/second)
- Use Conversation.typingUsers array for state tracking (already exists in entity)
- Real-time listener on Conversation to detect typing changes
- Lifecycle management to clear typing state when leaving chat
- Performance monitoring to ensure no composition lag

---

## What's Already Done (Infrastructure from Previous Stories)

### ✅ Conversation Entity (Epic 1, Story 1.3)

The `Conversation` entity already includes the `typingUsers` field:

**File:** `MessageAI/Domain/Entities/Conversation.swift`

```swift
struct Conversation: Codable, Equatable, Identifiable {
    let id: String
    var participantIds: [String]
    var typingUsers: [String]  // ✅ ALREADY EXISTS
    // ... other fields
}
```

**Database Schema:** `docs/architecture/database-schema.md`

```
conversations/
  └── {conversationId}/
      ├── typingUsers: string[]  // ✅ ALREADY IN FIRESTORE
```

### ✅ Cloud Function for Cleanup (Infrastructure Setup)

The `cleanupTypingIndicators` Cloud Function is already deployed:

**File:** `functions/src/index.ts`

```typescript
/**
 * Cloud Function: Clean up stale typing indicators
 * Scheduled to run every minute
 * Action: Sets typing status to false for users inactive > 5 seconds
 */
export const cleanupTypingIndicators = functions.pubsub
  .schedule("every 1 minutes")
  .onRun(async (context) => {
    const fiveSecondsAgo = admin.firestore.Timestamp.fromDate(
      new Date(Date.now() - 5000)
    );

    const staleTypingQuery = await admin.firestore()
      .collection("conversations")
      .where("typingUsers", "!=", {})
      .get();

    const batch = admin.firestore().batch();
    let updateCount = 0;

    staleTypingQuery.forEach((doc) => {
      const data = doc.data();
      const typingUsers = data.typingUsers || {};

      // Filter out stale typing indicators
      const updatedTypingUsers: Record<string, any> = {};
      let hasChanges = false;

      for (const [userId, typingData] of Object.entries(typingUsers)) {
        const lastTyping = (typingData as any).lastTyping;
        if (lastTyping && lastTyping > fiveSecondsAgo) {
          updatedTypingUsers[userId] = typingData;
        } else {
          hasChanges = true;
        }
      }

      if (hasChanges) {
        batch.update(doc.ref, {typingUsers: updatedTypingUsers});
        updateCount++;
      }
    });

    if (updateCount > 0) {
      await batch.commit();
      console.log(`Cleaned up ${updateCount} stale typing indicators`);
    }

    return null;
  });
```

**Status:** ✅ Deployed and running every 1 minute

**Benefits:**
- Prevents "stuck" typing indicators if user closes app while typing
- Automatic cleanup without iOS client intervention
- Handles edge cases (app crash, network loss during typing)

---

## What's NEW in Story 2.6

Story 2.6 adds the **iOS client-side implementation** for typing indicators:

### 1. ConversationRepositoryProtocol Extension

**NEW METHOD:**
```swift
/// Update typing state for current user in conversation
/// - Parameters:
///   - conversationId: The conversation ID
///   - userId: The user ID
///   - isTyping: True if user is typing, false if stopped
func updateTypingState(conversationId: String, userId: String, isTyping: Bool) async throws
```

### 2. FirebaseConversationRepository Implementation

**NEW METHOD:** Firestore update to add/remove userId from typingUsers array

### 3. ChatViewModel Typing State Management

**NEW:**
- `startTyping()` - Called when messageText changes
- `stopTyping()` - Called after 3s inactivity or on send
- `observeTypingUsers()` - Real-time listener for typingUsers changes
- Throttling logic (max 1 Firestore write per second)
- Timer for auto-stop after 3s inactivity

### 4. TypingIndicatorView SwiftUI Component

**NEW FILE:** Custom SwiftUI view showing "[Name] is typing..."

### 5. ChatView Integration

**UPDATE:** Display TypingIndicatorView below messages when typingUsers not empty

### 6. Unit Tests

**NEW FILE:** Test throttling, auto-stop, lifecycle clearing

---

## Tasks / Subtasks

### Task 0: Understand Existing Infrastructure (AC: Foundation)
- [ ] Review `Conversation.typingUsers` field in domain entity
- [ ] Review `cleanupTypingIndicators` Cloud Function in functions/src/index.ts
- [ ] Verify Cloud Function is deployed (check Firebase Console → Functions)
- [ ] Review Story 2.5 (Read Receipts) for similar real-time state patterns

### Task 1: Extend ConversationRepositoryProtocol (AC: 3)
- [ ] Add `updateTypingState(conversationId:userId:isTyping:) async throws` method signature
- [ ] Document method behavior (add user to array when true, remove when false)
- [ ] Add method to MockConversationRepository with tracking booleans

### Task 2: Implement updateTypingState in FirebaseConversationRepository (AC: 3, 4, 6, 7)
- [ ] Implement method using Firestore arrayUnion (add) and arrayRemove (remove)
- [ ] Use FieldValue.arrayUnion for adding userId
- [ ] Use FieldValue.arrayRemove for removing userId
- [ ] Handle errors with RepositoryError translation
- [ ] Log success/failure with console output

### Task 3: Add Typing State Management to ChatViewModel (AC: 4, 5, 6, 7, 8)
- [ ] Add `@Published var typingUserNames: [String]` property for UI binding
- [ ] Add private throttle timer: `private var typingThrottleTimer: Timer?`
- [ ] Add private auto-stop timer: `private var typingAutoStopTimer: Timer?`
- [ ] Add private flag: `private var isCurrentlyTyping: Bool = false`
- [ ] Implement `startTyping()` method with 1-second throttle
  - Check if already sent update within last second
  - If throttle allows, call repository.updateTypingState(isTyping: true)
  - Reset auto-stop timer (3 seconds)
- [ ] Implement `stopTyping()` method
  - Call repository.updateTypingState(isTyping: false)
  - Invalidate timers
- [ ] Add `.onChange(of: messageText)` handler to call startTyping()
- [ ] Add timer to call stopTyping() after 3 seconds of inactivity
- [ ] Call stopTyping() in `onDisappear()` to clear state when leaving chat
- [ ] Call stopTyping() in `sendMessage()` immediately before sending

### Task 4: Observe Typing Users in Real-Time (AC: 2, 5)
- [ ] Add `observeTypingUsers()` method in ChatViewModel
- [ ] Subscribe to Conversation updates via conversationRepository
- [ ] Extract typingUsers array from Conversation
- [ ] Filter out current user (don't show "You are typing...")
- [ ] Map user IDs to display names using cached users dictionary
- [ ] Update `@Published var typingUserNames` to trigger UI update
- [ ] Format names: "[Name] is typing..." (1 user) or "[Name], [Name] are typing..." (2+ users)

### Task 5: Create TypingIndicatorView SwiftUI Component (AC: 1, 2, 9)
- [ ] Create `MessageAI/Presentation/Components/TypingIndicatorView.swift`
- [ ] Accept `typingUserNames: [String]` as parameter
- [ ] Display formatted text: "[Name] is typing..." or "[Name], [Name] are typing..."
- [ ] Add animated dots (...) using SwiftUI animation
- [ ] Style: Gray italic text, small font (12pt)
- [ ] Add padding and background matching chat theme
- [ ] Handle empty array (return EmptyView)

### Task 6: Integrate TypingIndicatorView into ChatView (AC: 1)
- [ ] Display TypingIndicatorView at bottom of MessageKit messages
- [ ] Bind to viewModel.typingUserNames
- [ ] Position below last message (above input bar)
- [ ] Add animation for smooth appearance/disappearance

### Task 7: Lifecycle Management (AC: 6, 8)
- [ ] Call `viewModel.stopTyping()` in ChatView.onDisappear()
- [ ] Ensure typing state cleared when navigating away
- [ ] Test app backgrounding (should clear typing state)
- [ ] Test app termination (Cloud Function handles cleanup)

### Task 8: Unit Tests for ChatViewModel Typing Logic (AC: 10)
- [ ] Create `ChatViewModelTypingTests.swift` test file
- [ ] `testStartTyping_CallsRepository()` - Verify repository called with isTyping: true
- [ ] `testStopTyping_CallsRepository()` - Verify repository called with isTyping: false
- [ ] `testTypingThrottle_MaxOnePerSecond()` - Call startTyping() rapidly, verify single write
- [ ] `testAutoStop_AfterThreeSeconds()` - Start typing, wait 3s, verify stopTyping() called
- [ ] `testStopTyping_OnMessageSend()` - Send message, verify stopTyping() called
- [ ] `testStopTyping_OnViewDisappear()` - Simulate onDisappear, verify stopTyping() called
- [ ] `testObserveTypingUsers_FiltersCurrentUser()` - Verify current user not in typingUserNames
- [ ] `testObserveTypingUsers_FormatsNames()` - Single user: "[Name] is typing..."
- [ ] `testObserveTypingUsers_FormatsNamesGroup()` - Multiple users: "[Name], [Name] are typing..."

### Task 9: Unit Tests for ConversationRepository Typing Method (AC: 10)
- [ ] Add tests in `FirebaseConversationRepositoryTests.swift` (or create if missing)
- [ ] `testUpdateTypingState_AddsUser()` - isTyping: true adds userId to array
- [ ] `testUpdateTypingState_RemovesUser()` - isTyping: false removes userId from array
- [ ] `testUpdateTypingState_HandleError()` - Simulate Firestore error, verify RepositoryError thrown

### Task 10: Manual Testing Checklist (AC: 11, 12, 13)
- [ ] Test two simulators (User A and User B)
- [ ] User A starts typing → User B sees "[DisplayName] is typing..." within 500ms
- [ ] User A stops typing (3s) → User B sees indicator disappear
- [ ] User A sends message → Typing indicator cleared immediately
- [ ] User A leaves chat → Typing indicator cleared for User B
- [ ] Group chat: Multiple users typing → Shows "[Name], [Name] are typing..."
- [ ] Performance: Type rapidly, verify no lag in text input
- [ ] Performance: Send 10 messages quickly, verify typing indicators still responsive
- [ ] Regression: Message sending, editing, read receipts all still work

### Task 11: Integration Test (AC: 11)
- [ ] Create integration test: testTypingIndicator_RealTimeUpdate()
- [ ] User A starts typing (updateTypingState)
- [ ] User B observes conversation (listens to typingUsers)
- [ ] Verify User B sees User A in typingUsers within 1 second
- [ ] User A stops typing
- [ ] Verify User B sees User A removed from typingUsers

---

## Dev Notes

### Previous Story Context

**From Story 2.5 (Read Receipts):**

Story 2.5 established patterns for real-time state management using Firestore listeners. Key patterns:
- Real-time observation of Conversation document changes
- Efficient array manipulation (readBy array updates)
- Optimistic UI updates without rollback (best-effort)
- Lifecycle management (onAppear/onDisappear)

Story 2.6 applies similar patterns to typing indicators:
- Real-time observation of typingUsers array
- Add/remove user IDs using Firestore arrayUnion/arrayRemove
- Throttle updates to reduce Firestore writes
- Clear state on view lifecycle events

### Architecture Context

**Tech Stack:** [Source: docs/architecture/tech-stack.md]

- **Swift**: 5.9+, async/await for async operations
- **SwiftUI**: iOS 15+, declarative UI with @Published bindings
- **Combine**: Reactive state management for real-time updates
- **MessageKit**: 4.2.0, chat UI library (AC #9 mentions MessageKit typing indicator)
- **Firebase Firestore**: Real-time database with < 500ms listener latency

**Data Models:** [Source: docs/architecture/data-models.md#conversation]

```swift
struct Conversation: Codable, Equatable, Identifiable {
    let id: String
    var participantIds: [String]
    var typingUsers: [String]  // Array of user IDs currently typing
    // ...
}
```

**Database Schema:** [Source: docs/architecture/database-schema.md]

```
conversations/
  └── {conversationId}/
      ├── typingUsers: string[]  // Real-time array, updated frequently
```

**Firestore Security Rules:**

```javascript
// Conversations collection
match /conversations/{conversationId} {
  allow read: if isParticipant(resource.data);
  allow update: if isParticipant(resource.data);  // ✅ Allows typing state updates
}
```

Users who are participants can update the conversation (including typingUsers).

### Repository Protocol Extension

**File:** `MessageAI/Domain/Repositories/ConversationRepositoryProtocol.swift`

Add this method:

```swift
/// Update typing state for current user in conversation
/// - Parameters:
///   - conversationId: The conversation ID
///   - userId: The user ID
///   - isTyping: True if user is typing, false if stopped
func updateTypingState(conversationId: String, userId: String, isTyping: Bool) async throws
```

### FirebaseConversationRepository Implementation

**File:** `MessageAI/Data/Repositories/FirebaseConversationRepository.swift`

```swift
func updateTypingState(conversationId: String, userId: String, isTyping: Bool) async throws {
    do {
        let conversationRef = db.collection("conversations").document(conversationId)
        
        if isTyping {
            // Add user to typingUsers array
            try await conversationRef.updateData([
                "typingUsers": FieldValue.arrayUnion([userId])
            ])
            print("✅ Added \(userId) to typingUsers in conversation \(conversationId)")
        } else {
            // Remove user from typingUsers array
            try await conversationRef.updateData([
                "typingUsers": FieldValue.arrayRemove([userId])
            ])
            print("✅ Removed \(userId) from typingUsers in conversation \(conversationId)")
        }
    } catch {
        print("❌ Failed to update typing state: \(error.localizedDescription)")
        throw RepositoryError.from(error)
    }
}
```

**Key Points:**
- Use `FieldValue.arrayUnion` to add without duplicates
- Use `FieldValue.arrayRemove` to remove specific user ID
- No race condition issues (Firestore handles atomic array operations)
- Errors translated to RepositoryError

### ChatViewModel Typing State Management

**File:** `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift`

Add these properties:

```swift
// MARK: - Typing Indicator Properties

@Published var typingUserNames: [String] = []

private var typingThrottleTimer: Timer?
private var typingAutoStopTimer: Timer?
private var isCurrentlyTyping: Bool = false
private var lastTypingUpdateTime: Date = .distantPast
```

Add these methods:

```swift
// MARK: - Typing Indicator Methods

/// Start typing indicator (throttled to max 1 update per second)
func startTyping() {
    let now = Date()
    let timeSinceLastUpdate = now.timeIntervalSince(lastTypingUpdateTime)
    
    // Throttle: Only send update if > 1 second since last update
    guard timeSinceLastUpdate >= 1.0 else {
        // Reset auto-stop timer even if throttled
        resetAutoStopTimer()
        return
    }
    
    // Send typing state to Firestore
    Task {
        do {
            try await conversationRepository.updateTypingState(
                conversationId: conversationId,
                userId: currentUserId,
                isTyping: true
            )
            lastTypingUpdateTime = Date()
            isCurrentlyTyping = true
        } catch {
            print("⚠️ Failed to set typing state: \(error.localizedDescription)")
        }
    }
    
    // Reset auto-stop timer (3 seconds)
    resetAutoStopTimer()
}

/// Stop typing indicator
func stopTyping() {
    guard isCurrentlyTyping else { return }
    
    Task {
        do {
            try await conversationRepository.updateTypingState(
                conversationId: conversationId,
                userId: currentUserId,
                isTyping: false
            )
            isCurrentlyTyping = false
        } catch {
            print("⚠️ Failed to clear typing state: \(error.localizedDescription)")
        }
    }
    
    // Invalidate timers
    typingAutoStopTimer?.invalidate()
    typingAutoStopTimer = nil
}

/// Reset auto-stop timer (called on each keystroke)
private func resetAutoStopTimer() {
    typingAutoStopTimer?.invalidate()
    typingAutoStopTimer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: false) { [weak self] _ in
        self?.stopTyping()
    }
}

/// Observe typing users in real-time
private func observeTypingUsers() {
    // Listen to conversation changes
    conversationRepository.observeConversations(userId: currentUserId)
        .compactMap { conversations in
            conversations.first { $0.id == self.conversationId }
        }
        .sink { [weak self] conversation in
            guard let self = self else { return }
            
            // Filter out current user (don't show "You are typing...")
            let otherUsersTyping = conversation.typingUsers.filter { $0 != self.currentUserId }
            
            // Map user IDs to display names
            let names = otherUsersTyping.compactMap { userId in
                self.users[userId]?.displayName
            }
            
            // Format names for display
            self.typingUserNames = names
        }
        .store(in: &cancellables)
}
```

Update `init()` to call `observeTypingUsers()`:

```swift
init(...) {
    // ... existing init code
    observeMessages()
    observeTypingUsers()  // ← NEW
    setupNetworkMonitoring()
}
```

Update `onDisappear()` to call `stopTyping()`:

```swift
func onDisappear() {
    stopTyping()  // ← NEW: Clear typing state when leaving chat
    // ... existing cleanup code
}
```

Update `sendMessage()` to call `stopTyping()` immediately:

```swift
func sendMessage() {
    stopTyping()  // ← NEW: Clear typing immediately on send
    
    // ... existing sendMessage code
}
```

Add `.onChange(of: messageText)` in ChatView:

```swift
.onChange(of: viewModel.messageText) { oldValue, newValue in
    if !newValue.isEmpty && oldValue != newValue {
        viewModel.startTyping()
    }
}
```

### TypingIndicatorView Component

**File:** `MessageAI/Presentation/Components/TypingIndicatorView.swift`

```swift
import SwiftUI

/// Displays typing indicator: "[Name] is typing..." or "[Name], [Name] are typing..."
struct TypingIndicatorView: View {
    let typingUserNames: [String]
    
    @State private var dotCount: Int = 1
    
    var body: some View {
        if typingUserNames.isEmpty {
            EmptyView()
        } else {
            HStack(spacing: 4) {
                Text(formattedText)
                    .font(.system(size: 12))
                    .foregroundColor(.gray)
                    .italic()
                
                // Animated dots
                Text(String(repeating: ".", count: dotCount))
                    .font(.system(size: 12))
                    .foregroundColor(.gray)
                    .onAppear {
                        startAnimation()
                    }
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(Color(.systemGray6))
            .cornerRadius(12)
            .padding(.leading, 12)
            .padding(.bottom, 4)
        }
    }
    
    private var formattedText: String {
        if typingUserNames.count == 1 {
            return "\(typingUserNames[0]) is typing"
        } else if typingUserNames.count == 2 {
            return "\(typingUserNames[0]) and \(typingUserNames[1]) are typing"
        } else {
            let names = typingUserNames.prefix(2).joined(separator: ", ")
            return "\(names), and \(typingUserNames.count - 2) more are typing"
        }
    }
    
    private func startAnimation() {
        Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { _ in
            withAnimation {
                dotCount = (dotCount % 3) + 1
            }
        }
    }
}
```

### ChatView Integration

**File:** `MessageAI/Presentation/Views/Chat/ChatView.swift`

Add typing indicator above the message input bar:

```swift
var body: some View {
    VStack(spacing: 0) {
        // Existing MessageKit wrapper
        MessageKitWrapper(viewModel: viewModel)
        
        // NEW: Typing indicator
        TypingIndicatorView(typingUserNames: viewModel.typingUserNames)
        
        // Existing message input bar
        // ...
    }
    .onChange(of: viewModel.messageText) { oldValue, newValue in
        if !newValue.isEmpty && oldValue != newValue {
            viewModel.startTyping()
        }
    }
}
```

### Mock Repository Updates

**File:** `MessageAITests/Data/Mocks/MockConversationRepository.swift`

Add these properties and method:

```swift
// Typing state tracking
var updateTypingStateCalled = false
var capturedTypingConversationId: String?
var capturedTypingUserId: String?
var capturedIsTyping: Bool?

func updateTypingState(conversationId: String, userId: String, isTyping: Bool) async throws {
    updateTypingStateCalled = true
    capturedTypingConversationId = conversationId
    capturedTypingUserId = userId
    capturedIsTyping = isTyping
    
    if shouldFail {
        throw mockError ?? RepositoryError.networkError
    }
}

func reset() {
    // ... existing reset code
    updateTypingStateCalled = false
    capturedTypingConversationId = nil
    capturedTypingUserId = nil
    capturedIsTyping = nil
}
```

### Performance Considerations

**Throttling Strategy:**

Typing indicators generate MANY Firestore writes (every keystroke). Story 2.6 uses throttling to reduce costs:

- **Max 1 update per second**: Even if user types 100 characters in 2 seconds, only 2 Firestore writes occur
- **Auto-stop after 3 seconds**: Prevents stuck "is typing" if user stops mid-sentence
- **Immediate clear on send**: Typing cleared instantly when message sent

**Firestore Writes Estimate:**

- Without throttling: 60+ writes/minute (1 per keystroke)
- With 1-second throttle: 60 writes/minute maximum (realistic: 10-20 writes/minute)
- Savings: 70-80% reduction in writes

**Cloud Function Backup:**

The `cleanupTypingIndicators` Cloud Function provides reliability:

- Runs every 1 minute
- Removes stale typing states (> 5 seconds old)
- Handles edge cases (app crash, network loss)
- No client-side cleanup needed for edge cases

### Edge Cases

1. **User closes app while typing:** Cloud Function cleans up within 1 minute
2. **Network loss while typing:** Update queued, sent when online (Firestore offline persistence)
3. **Rapid typing (100+ chars/second):** Throttle prevents excessive writes
4. **Multiple users typing simultaneously:** Array supports multiple user IDs
5. **User leaves chat mid-typing:** `onDisappear()` clears state immediately

### Testing Strategy

[Source: docs/architecture/testing-best-practices.md]

**Unit Tests:**

```bash
# During development (5-20 seconds)
./scripts/test-story.sh ChatViewModelTypingTests
```

**Epic Tests:**

```bash
# Before marking story complete (20-40 seconds)
./scripts/test-epic.sh 2
```

**Full Suite:**

```bash
# Before committing (1-2 minutes)
./scripts/quick-test.sh
```

**Test File Locations:**

```
MessageAITests/
├── Presentation/
│   └── ViewModels/
│       └── ChatViewModelTypingTests.swift  ← NEW
└── Data/
    └── Repositories/
        └── FirebaseConversationRepositoryTests.swift  ← UPDATE
```

**Key Test Scenarios:**

1. **Throttling:** Call startTyping() 10 times in 500ms → Verify 1 repository call
2. **Auto-stop:** Start typing, wait 3.1 seconds → Verify stopTyping() called
3. **Send clears:** Call sendMessage() → Verify stopTyping() called
4. **View lifecycle:** Simulate onDisappear() → Verify stopTyping() called
5. **Name formatting:** 1 user typing → "[Name] is typing..."
6. **Name formatting group:** 3 users typing → "[Name], [Name], and 1 more are typing"
7. **Current user filtered:** Current user in typingUsers → Not shown in UI

### Manual Testing Workflow

**Setup:**

1. Open two iOS simulators
2. Sign in as test1@messageai.dev on Device A
3. Sign in as test2@messageai.dev on Device B
4. Open same conversation on both devices

**Test Scenarios:**

1. **Basic Typing (AC #1, #2, #5):**
   - Device A: Start typing in message input
   - Device B: Observe typing indicator appears within 500ms
   - Device B: See "Test User 1 is typing..."

2. **Auto-Stop (AC #4):**
   - Device A: Type a few characters, then stop
   - Device B: Wait 3 seconds
   - Device B: Typing indicator disappears automatically

3. **Send Clears Indicator (AC #4):**
   - Device A: Type message and send
   - Device B: Typing indicator disappears immediately (before send completes)

4. **Leave Chat Clears (AC #6):**
   - Device A: Start typing
   - Device A: Navigate back to conversations list
   - Device B: Typing indicator disappears within 500ms

5. **Group Chat (AC #2):**
   - Create group with test1, test2, test3
   - Device A (test1): Start typing
   - Device B (test2): Start typing
   - Device C (test3): See "Test User 1, Test User 2 are typing..."

6. **Performance (AC #12):**
   - Device A: Type rapidly (100+ characters in 10 seconds)
   - Device A: Verify no lag in text input
   - Device B: Verify typing indicator still responsive

7. **Regression (AC #13):**
   - Send 5 messages (verify all delivered)
   - Edit a message (verify edit successful)
   - Mark messages as read (verify read receipts update)

### Accessibility

**VoiceOver Support:**

```swift
TypingIndicatorView()
    .accessibilityLabel("Typing indicator")
    .accessibilityValue(formattedText)
```

Users with VoiceOver enabled will hear: "Typing indicator. [Name] is typing."

### WCAG AA Compliance

- **Color Contrast:** Gray text on system background meets 4.5:1 ratio
- **Text Size:** Respects Dynamic Type (system font)
- **Non-essential animation:** Dot animation can be disabled (system accessibility settings)

---

## Testing

[Source: docs/architecture/testing-best-practices.md]

### Unit Tests (8-10 tests)

**File:** `MessageAITests/Presentation/ViewModels/ChatViewModelTypingTests.swift`

1. `testStartTyping_CallsRepository()` - Verify repository.updateTypingState(isTyping: true) called
2. `testStopTyping_CallsRepository()` - Verify repository.updateTypingState(isTyping: false) called
3. `testTypingThrottle_MaxOnePerSecond()` - Call startTyping() 5 times in 0.5s, verify 1 call
4. `testAutoStop_AfterThreeSeconds()` - Start typing, wait 3.1s, verify stopTyping() called
5. `testStopTyping_OnMessageSend()` - Call sendMessage(), verify stopTyping() called first
6. `testStopTyping_OnViewDisappear()` - Call onDisappear(), verify stopTyping() called
7. `testObserveTypingUsers_FiltersCurrentUser()` - Current user in typingUsers → Not in typingUserNames
8. `testObserveTypingUsers_FormatsNamesSingle()` - 1 user → "[Name] is typing..."
9. `testObserveTypingUsers_FormatsNamesMultiple()` - 2 users → "[Name], [Name] are typing..."
10. `testObserveTypingUsers_FormatsNamesMany()` - 5 users → "[Name], [Name], and 3 more are typing"

**Test Execution:**

```bash
# Run story tests during development
./scripts/test-story.sh ChatViewModelTypingTests

# Run all Epic 2 tests before marking complete
./scripts/test-epic.sh 2
```

### Integration Tests (1 test)

**File:** `MessageAITests/Integration/TypingIndicatorIntegrationTests.swift`

**Test:** `testTypingIndicator_RealTimeUpdate()`

**Setup:**
- Requires Firebase Emulator running
- Creates two test users
- Creates conversation between users

**Steps:**
1. User A calls updateTypingState(isTyping: true)
2. User B observes conversation (real-time listener)
3. Verify User B sees User A in conversation.typingUsers within 1 second
4. User A calls updateTypingState(isTyping: false)
5. Verify User B sees User A removed from conversation.typingUsers

**Skip if emulator not running:**

```swift
override func setUp() async throws {
    throw XCTSkip("Requires Firebase Emulator - run ./scripts/start-emulator.sh")
}
```

### Manual Testing Checklist

Execute all scenarios from "Manual Testing Workflow" section above.

**Required:**
- Two iOS simulators (or real devices)
- Test users: test1@messageai.dev, test2@messageai.dev
- Existing conversation between users

**Verification:**
- [ ] Typing indicator appears within 500ms (AC #5)
- [ ] Auto-stops after 3 seconds (AC #4)
- [ ] Clears on send (AC #4)
- [ ] Clears on leave chat (AC #6)
- [ ] Group chat shows multiple users (AC #2)
- [ ] No input lag during rapid typing (AC #12)
- [ ] Message sending/editing still works (AC #13)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-10-22 | 1.0 | Story created - Typing Indicators | Bob (SM) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

---

## QA Results

*This section will be populated by QA agent after implementation.*

