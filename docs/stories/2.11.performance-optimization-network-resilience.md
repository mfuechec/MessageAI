# Story 2.11: Performance Optimization & Network Resilience

## Status

**Draft**

---

## Story

**As a** developer,
**I want** the app to handle poor network conditions and high message volume gracefully,
**so that** users experience reliable messaging even under adverse conditions.

---

## Acceptance Criteria

1. Firestore queries optimized with proper indexing (composite indexes created)
2. Message pagination implemented (load 50 most recent, fetch older on scroll)
3. Conversation list pagination for users with 100+ conversations
4. Image thumbnails used in conversation previews (not full-resolution images)
5. Firestore listeners cleaned up properly when views dismissed (prevent memory leaks)
6. Network error handling with exponential backoff retry logic
7. Timeout handling for long-running operations (10 second max wait for network calls)
8. App handles 3G network speeds without crashes or data loss
9. Rapid-fire messaging test: Send 20+ messages quickly, verify all delivered in order
10. Performance baseline: App launch < 1 second, conversation load < 1 second, message send < 2 seconds
11. Memory profiling: App uses < 150MB RAM with 10 conversations loaded
12. Battery usage acceptable (no background processing runaway)
13. Offline → Online transition smooth (no crashes, queued messages process)
14. **Relative Timestamp Updates:** Conversation list timestamps update periodically
    - "2 minutes ago" becomes "3 minutes ago" automatically
    - Timer updates every 60 seconds for active conversations
    - Pauses when app backgrounded (battery optimization)
    - Uses SwiftUI `.onReceive(timer)` pattern
    - No flicker or visual disruption during updates
15. Integration test: Toggle airplane mode repeatedly during active messaging, verify no data loss
16. Load testing: 1000 message conversation loads and scrolls smoothly
17. **User Cache Optimization (Discovered in Story 2.2):**
    - ConversationsListViewModel implements user caching to prevent redundant Firebase reads
    - Cache fetched users with 5-minute TTL (time-to-live)
    - Online status uses separate 30-second TTL
    - LRU eviction strategy (max 100 users)
    - Message edit triggers 0-1 participant fetches (vs 50+ without cache)
    - Profile changes appear within 5 minutes
    - Firebase read count reduced by 90%+ on conversation list updates
    - **Impact:** Fixes performance issue where editing 1 message triggers ~50+ redundant user reads
    - **Reference:** See Story 2.2 Dev Agent Record for console logs and detailed analysis

---

## Previous Story Context

### Key Learnings from Story 2.10 (Push Notifications)

**Performance Notes:**
- Notification permissions request: <100ms
- FCM token registration: 1-2 seconds (Firebase SDK)
- Badge count updates: Instant (<10ms calculation)
- Deep linking navigation: <100ms
- All operations non-blocking (async/await)

**Patterns Established:**
- Real-time listeners with Combine publishers
- Auto-cleanup with `cancellables` storage
- Optimistic UI updates throughout Epic 2
- SwiftUI `.onReceive()` for NotificationCenter events

### Key Learnings from Story 2.9 (Offline Queue)

**Performance Validation:**
- UserDefaults-based storage provides < 100ms read/write
- Large queue test (100 messages) completes successfully
- Queue load time instant (< 100ms)
- Sequential sending prevents race conditions

**Memory Management:**
- UserDefaults limit: 500KB (~1000 messages)
- Proper Combine cancellables cleanup
- NetworkMonitor singleton pattern

### User Cache Pattern from Story 2.2

**Discovery Context:**
Story 2.2 (Message Editing) revealed a critical performance issue: editing a single message triggered 50+ redundant user profile fetches in the conversations list. This was discovered during manual testing when console logs showed excessive Firebase reads.

**Solution Implemented:**
- User cache with TTL (time-to-live) expiration
- Separate cache entries for profile vs online status
- LRU eviction for memory management
- Result: 90%+ reduction in Firebase reads

**Relevance to Story 2.11:**
This cache optimization is part of the broader performance work. Story 2.11 should validate that caching is working correctly and document the performance gains.

---

## Dev Notes

### Architecture Context

**Performance is a FIRST-CLASS requirement for Story 2.11, not an afterthought.**

This story focuses on **optimization and resilience**, building on the infrastructure from Epic 1 and Epic 2. All previous stories implemented features with optimistic UI and offline support. Story 2.11 ensures the app performs well under stress: poor networks, large data volumes, and resource constraints.

---

### Tech Stack

[Source: docs/architecture/tech-stack.md]

- **Language**: Swift 5.9+ with async/await for async operations
- **UI Framework**: SwiftUI (iOS 15+) with declarative UI
- **State Management**: Combine + @Published for reactive bindings
- **Database**: Cloud Firestore with real-time listeners and offline persistence
- **Testing**: XCTest with XCTMeasure for performance baselines
- **Monitoring**: Firebase Crashlytics for crash reporting, Firebase Analytics for usage tracking
- **Logging**: OSLog (native iOS logging framework)

---

### Data Models

[Source: docs/architecture/data-models.md]

**Message Entity:**
- `id: String` - UUID
- `conversationId: String` - Parent conversation (INDEXED)
- `timestamp: Date` - Server timestamp (INDEXED)
- `status: MessageStatus` - Enum (queued, sending, sent, delivered, read, failed)
- `attachments: [MessageAttachment]` - Images/documents

**Conversation Entity:**
- `id: String` - UUID
- `participantIds: [String]` - User IDs (INDEXED with array-contains)
- `lastMessageTimestamp: Date?` - For sorting conversations
- `unreadCounts: [String: Int]` - Per-user unread counts

---

### Database Schema & Query Optimization

[Source: docs/architecture/database-schema.md]

**Composite Indexes Required (AC #1):**

Story 2.11 requires the following composite indexes in `firestore.indexes.json`:

```json
{
  "indexes": [
    {
      "collectionGroup": "messages",
      "fields": [
        { "fieldPath": "conversationId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    }
  ]
}
```

**Deploy with:**
```bash
firebase deploy --only firestore:indexes --project messageai-dev-1f2ec
```

**Query Patterns:**

1. **Messages Query (with pagination):**
```swift
db.collection("messages")
    .whereField("conversationId", isEqualTo: conversationId)
    .order(by: "timestamp", descending: true)
    .limit(to: 50)  // AC #2
```

2. **Conversations Query (with pagination):**
```swift
db.collection("conversations")
    .whereField("participantIds", arrayContains: currentUserId)
    .order(by: "lastMessageTimestamp", descending: true)
    .limit(to: 50)  // AC #3
```

3. **Load More Messages (pagination):**
```swift
query.start(afterDocument: lastDocument)
    .limit(to: 50)
```

---

### iOS App Architecture

[Source: docs/architecture/ios-app-architecture.md]

**Files to Modify:**

1. `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift`
   - Add message pagination logic
   - Add Firestore listener cleanup
   - Add network error handling with exponential backoff
   - Add timeout handling (10 seconds max)

2. `MessageAI/Presentation/ViewModels/Conversations/ConversationsListViewModel.swift`
   - Add conversation pagination logic
   - Optimize user cache (AC #17)
   - Add relative timestamp updates (AC #14)
   - Add memory profiling instrumentation

3. `MessageAI/Data/Repositories/FirebaseMessageRepository.swift`
   - Add pagination support to `observeMessages()` method
   - Add `loadMoreMessages()` method for fetching older messages
   - Add exponential backoff retry logic

4. `MessageAI/Data/Repositories/FirebaseConversationRepository.swift`
   - Add pagination support to `observeConversations()` method
   - Add `loadMoreConversations()` method

5. `MessageAI/Presentation/Views/Chat/ChatView.swift`
   - Add scroll detection for pagination trigger
   - Add loading indicator for "Load More" state

6. `MessageAI/Presentation/Views/Conversations/ConversationsListView.swift`
   - Add scroll detection for conversation list pagination
   - Add timer for relative timestamp updates

**New Files:**

7. `MessageAI/Presentation/Utils/RelativeTimestampFormatter.swift`
   - Utility for formatting relative timestamps ("2m ago", "5h ago", "Yesterday")
   - Used by ConversationsListViewModel

8. `MessageAI/Data/Network/NetworkRetryPolicy.swift`
   - Exponential backoff retry logic (AC #6)
   - Used by all Firebase repositories

**Test Files:**

9. `MessageAITests/Presentation/ViewModels/ChatViewModelPaginationTests.swift`
10. `MessageAITests/Presentation/ViewModels/ConversationsListViewModelPaginationTests.swift`
11. `MessageAITests/Performance/PerformanceBaselineTests.swift` (NEW)

---

### Coding Standards

[Source: docs/architecture/coding-standards.md]

**Critical Rules for Story 2.11:**

1. **Firestore Query Limits (AC #2, #3):**
   - ✅ ALWAYS use `.limit(to: 50)` on queries
   - ❌ NEVER query without limits (expensive, slow)

2. **Firestore Listener Cleanup (AC #5):**
   - ✅ Store listeners in `cancellables` and cancel on deinit
   - ❌ Memory leaks from orphaned listeners

3. **Exponential Backoff Pattern (AC #6):**
   - ✅ Retry delays: 1s, 2s, 4s, 8s (max 3 retries)
   - ❌ Fixed retry intervals (hammers server)

4. **Timeout Handling (AC #7):**
   - ✅ 10 second timeout for network calls
   - ❌ Indefinite waits (bad UX)

5. **Pagination Pattern:**
   - ✅ Store `lastDocument: DocumentSnapshot?` for pagination
   - ✅ Load 50 items at a time
   - ❌ Load entire dataset upfront

---

### Testing Strategy

[Source: docs/architecture/testing-strategy.md]

**Tier 1: Story-Level Tests (5-20 seconds)**
```bash
./scripts/test-story.sh ChatViewModelPaginationTests
./scripts/test-story.sh ConversationsListViewModelPaginationTests
```

**Tier 2: Epic-Level Tests (20-40 seconds)**
```bash
./scripts/test-epic.sh 2
```

**Tier 3: Performance Baselines (NEW for Story 2.11)**
```bash
xcodebuild test -scheme MessageAI \
  -destination 'platform=iOS Simulator,name=iPhone 17 Pro' \
  -only-testing:MessageAITests/Performance/PerformanceBaselineTests
```

**Test Coverage Target:** 70%+ for modified files

**Unit Tests Required:**
- Message pagination tests (load 50, load more, end of list)
- Conversation pagination tests (load 50, load more)
- Exponential backoff retry tests
- Timeout handling tests
- Firestore listener cleanup tests
- Relative timestamp update tests
- User cache TTL expiration tests

**Performance Tests Required (AC #10, #11):**
- App launch time < 1 second
- Conversation load time < 1 second
- Message send time < 2 seconds
- Memory usage < 150MB with 10 conversations
- 1000-message conversation load test

**Integration Tests (Firebase Emulator):**
- Rapid-fire messaging (20+ messages)
- Offline → Online transition
- Toggle airplane mode repeatedly
- Large dataset pagination (1000 messages)

---

### Network Resilience Patterns

**Exponential Backoff Retry Logic (AC #6):**

Create `MessageAI/Data/Network/NetworkRetryPolicy.swift`:

```swift
import Foundation

struct NetworkRetryPolicy {
    static let maxRetries = 3

    /// Calculate exponential backoff delay: 1s, 2s, 4s
    static func delay(for attempt: Int) -> TimeInterval {
        return pow(2.0, Double(attempt))
    }

    /// Retry async operation with exponential backoff
    static func retry<T>(
        maxAttempts: Int = maxRetries,
        operation: () async throws -> T
    ) async throws -> T {
        var attempt = 0

        while true {
            do {
                return try await operation()
            } catch {
                attempt += 1

                if attempt >= maxAttempts {
                    throw error
                }

                let delaySeconds = delay(for: attempt)
                try await Task.sleep(nanoseconds: UInt64(delaySeconds * 1_000_000_000))

                print("⚠️ Retry attempt \(attempt)/\(maxAttempts) after \(delaySeconds)s")
            }
        }
    }
}
```

**Usage in Repositories:**

```swift
func sendMessage(_ message: Message) async throws {
    try await NetworkRetryPolicy.retry {
        try await db.collection("messages").document(message.id).setData(messageData)
    }
}
```

---

### Pagination Implementation

**Message Pagination (AC #2, #16):**

Update `ChatViewModel`:

```swift
@Published var messages: [Message] = []
@Published var isLoadingMore: Bool = false
@Published var hasMoreMessages: Bool = true

private var lastMessageDocument: DocumentSnapshot?
private let pageSize = 50

func loadMoreMessages() async {
    guard !isLoadingMore && hasMoreMessages else { return }

    isLoadingMore = true

    do {
        let olderMessages = try await messageRepository.loadMoreMessages(
            conversationId: conversationId,
            after: lastMessageDocument,
            limit: pageSize
        )

        if olderMessages.count < pageSize {
            hasMoreMessages = false
        }

        messages.insert(contentsOf: olderMessages, at: 0)
        lastMessageDocument = /* store last doc */

    } catch {
        errorMessage = "Failed to load more messages"
    }

    isLoadingMore = false
}
```

**Trigger from ChatView:**

```swift
ScrollView {
    LazyVStack {
        ForEach(viewModel.messages) { message in
            MessageBubbleView(message: message)
                .onAppear {
                    // Load more when scrolling to top
                    if message.id == viewModel.messages.first?.id {
                        Task {
                            await viewModel.loadMoreMessages()
                        }
                    }
                }
        }
    }
}
```

---

### Relative Timestamp Updates (AC #14)

**Create Utility:**

`MessageAI/Presentation/Utils/RelativeTimestampFormatter.swift`:

```swift
import Foundation

struct RelativeTimestampFormatter {
    /// Format timestamp relative to now: "2m ago", "5h ago", "Yesterday"
    static func format(_ date: Date) -> String {
        let now = Date()
        let interval = now.timeIntervalSince(date)

        if interval < 60 {
            return "Now"
        } else if interval < 3600 {
            let minutes = Int(interval / 60)
            return "\(minutes)m ago"
        } else if interval < 86400 {
            let hours = Int(interval / 3600)
            return "\(hours)h ago"
        } else if interval < 172800 {
            return "Yesterday"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d"
            return formatter.string(from: date)
        }
    }
}
```

**Update ConversationsListViewModel:**

```swift
import Combine

private var timestampTimer: AnyCancellable?

func startTimestampUpdates() {
    timestampTimer = Timer.publish(every: 60, on: .main, in: .common)
        .autoconnect()
        .sink { [weak self] _ in
            // Trigger SwiftUI update
            self?.objectWillChange.send()
        }
}

func stopTimestampUpdates() {
    timestampTimer?.cancel()
    timestampTimer = nil
}
```

**Update ConversationsListView:**

```swift
.onAppear {
    viewModel.startTimestampUpdates()
}
.onDisappear {
    viewModel.stopTimestampUpdates()
}
```

---

### User Cache Optimization (AC #17)

**From Story 2.2 Context:**

The user cache was implemented during Story 2.2 to fix a performance issue where editing a single message triggered 50+ redundant user profile fetches.

**Validation Required for Story 2.11:**

1. **Verify cache is working:**
   - Edit a message
   - Check console logs
   - Confirm 0-1 user fetches (not 50+)

2. **Verify TTL expiration:**
   - Profile changes appear within 5 minutes
   - Online status updates within 30 seconds

3. **Verify LRU eviction:**
   - Load 100+ users
   - Verify cache size stays at max 100 users

**No new implementation needed** - just validation and documentation.

---

### Performance Baselines (AC #10, #11)

**Create Performance Test File:**

`MessageAITests/Performance/PerformanceBaselineTests.swift`:

```swift
import XCTest
@testable import MessageAI

class PerformanceBaselineTests: XCTestCase {

    // AC #10: App launch < 1 second
    func testAppLaunchTime() {
        measure {
            // Simulate app launch
            let container = DIContainer()
            _ = container.makeAuthViewModel()
        }

        // Assert: < 1 second
    }

    // AC #10: Conversation load < 1 second
    func testConversationLoadTime() async {
        let viewModel = DIContainer.shared.makeConversationsListViewModel(currentUserId: "test")

        measure {
            // Load conversations
            Task {
                await viewModel.loadConversations()
            }
        }
    }

    // AC #11: Memory usage < 150MB with 10 conversations
    func testMemoryUsageWith10Conversations() async {
        let viewModel = DIContainer.shared.makeConversationsListViewModel(currentUserId: "test")

        // Load 10 conversations with messages
        await viewModel.loadConversations()

        let memoryUsage = getMemoryUsage()
        XCTAssertLessThan(memoryUsage, 150_000_000, "Memory usage exceeds 150MB")
    }

    private func getMemoryUsage() -> UInt64 {
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4

        let result = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }

        return result == KERN_SUCCESS ? info.resident_size : 0
    }
}
```

---

### Firestore Listener Cleanup (AC #5)

**Pattern to Enforce:**

```swift
import Combine

class ChatViewModel: ObservableObject {
    private var cancellables = Set<AnyCancellable>()

    func observeMessages() {
        messageRepository.observeMessages(conversationId: conversationId)
            .receive(on: DispatchQueue.main)
            .sink { messages in
                self.messages = messages
            }
            .store(in: &cancellables)  // ← Stored for cleanup
    }

    deinit {
        cancellables.forEach { $0.cancel() }
        print("✅ ChatViewModel deinitialized - listeners cleaned up")
    }
}
```

**Validation:**

Run app with Instruments (Leaks tool) to verify no orphaned listeners.

---

## Tasks / Subtasks

### Task 1: Create Composite Indexes for Firestore (AC: 1)
- [ ] 1.1: Create `firestore.indexes.json` in project root (if not exists)
- [ ] 1.2: Add composite index for messages (conversationId + timestamp)
- [ ] 1.3: Add composite index for conversations (participantIds + lastMessageTimestamp)
- [ ] 1.4: Deploy indexes to dev environment: `firebase deploy --only firestore:indexes --project messageai-dev-1f2ec`
- [ ] 1.5: Verify indexes in Firebase Console (Firestore → Indexes tab)

### Task 2: Create Network Retry Policy Utility (AC: 6, 7)
- [ ] 2.1: Create `MessageAI/Data/Network/NetworkRetryPolicy.swift`
- [ ] 2.2: Implement exponential backoff function (1s, 2s, 4s delays)
- [ ] 2.3: Implement generic `retry()` method with maxAttempts parameter
- [ ] 2.4: Add timeout handling (10 second max per attempt)
- [ ] 2.5: Write unit test: `testExponentialBackoffDelays()`
- [ ] 2.6: Write unit test: `testRetrySucceedsAfterFailure()`
- [ ] 2.7: Write unit test: `testRetryThrowsAfterMaxAttempts()`
- [ ] 2.8: Write unit test: `testTimeoutEnforced()`

### Task 3: Implement Message Pagination in ChatViewModel (AC: 2, 16)
- [ ] 3.1: Add `@Published var isLoadingMore: Bool = false`
- [ ] 3.2: Add `@Published var hasMoreMessages: Bool = true`
- [ ] 3.3: Add `private var lastMessageDocument: DocumentSnapshot?`
- [ ] 3.4: Add `private let pageSize = 50`
- [ ] 3.5: Implement `loadMoreMessages() async` method
- [ ] 3.6: Update `observeMessages()` to only load 50 most recent
- [ ] 3.7: Add `MessageRepositoryProtocol.loadMoreMessages(after:limit:)` protocol method
- [ ] 3.8: Implement in FirebaseMessageRepository
- [ ] 3.9: Write unit test: `testLoadMoreMessages_LoadsOlderMessages()`
- [ ] 3.10: Write unit test: `testLoadMoreMessages_SetsHasMoreFalse_WhenEndReached()`
- [ ] 3.11: Write unit test: `testLoadMoreMessages_PreventsConcurrentLoads()`

### Task 4: Add Pagination Trigger to ChatView (AC: 2)
- [ ] 4.1: Add `.onAppear` to first message in list
- [ ] 4.2: Trigger `viewModel.loadMoreMessages()` when scrolling to top
- [ ] 4.3: Add loading indicator at top of chat (when `isLoadingMore == true`)
- [ ] 4.4: Handle edge case: No more messages (show "Beginning of conversation")
- [ ] 4.5: Manual test: Scroll to top, verify older messages load

### Task 5: Implement Conversation Pagination in ConversationsListViewModel (AC: 3)
- [ ] 5.1: Add `@Published var isLoadingMoreConversations: Bool = false`
- [ ] 5.2: Add `@Published var hasMoreConversations: Bool = true`
- [ ] 5.3: Add `private var lastConversationDocument: DocumentSnapshot?`
- [ ] 5.4: Implement `loadMoreConversations() async` method
- [ ] 5.5: Update `observeConversations()` to limit to 50
- [ ] 5.6: Add `ConversationRepositoryProtocol.loadMoreConversations(after:limit:)` protocol method
- [ ] 5.7: Implement in FirebaseConversationRepository
- [ ] 5.8: Write unit test: `testLoadMoreConversations_LoadsOlderConversations()`
- [ ] 5.9: Write unit test: `testConversationPagination_HandlesLargeDataset()`

### Task 6: Create Relative Timestamp Formatter (AC: 14)
- [ ] 6.1: Create `MessageAI/Presentation/Utils/RelativeTimestampFormatter.swift`
- [ ] 6.2: Implement `format(_ date: Date) -> String` method
- [ ] 6.3: Handle cases: "Now", "Xm ago", "Xh ago", "Yesterday", "MMM d"
- [ ] 6.4: Write unit test: `testRelativeTimestampFormatting()`
- [ ] 6.5: Test edge cases: Same minute, 1 hour ago, yesterday, last week

### Task 7: Add Relative Timestamp Updates to ConversationsListView (AC: 14)
- [ ] 7.1: Add `timestampTimer: AnyCancellable?` to ConversationsListViewModel
- [ ] 7.2: Implement `startTimestampUpdates()` method (60-second timer)
- [ ] 7.3: Implement `stopTimestampUpdates()` method
- [ ] 7.4: Call `startTimestampUpdates()` in ConversationsListView `.onAppear`
- [ ] 7.5: Call `stopTimestampUpdates()` in ConversationsListView `.onDisappear`
- [ ] 7.6: Update ConversationRowView to use RelativeTimestampFormatter
- [ ] 7.7: Write unit test: `testTimestampUpdatesEvery60Seconds()`
- [ ] 7.8: Manual test: Verify timestamps update without flickering

### Task 8: Validate User Cache Optimization (AC: 17)
- [ ] 8.1: Review Story 2.2 Dev Agent Record for cache implementation details
- [ ] 8.2: Manual test: Edit message, check console logs for user fetch count
- [ ] 8.3: Verify 0-1 user fetches (not 50+)
- [ ] 8.4: Test TTL expiration: Wait 5 minutes, verify profile changes appear
- [ ] 8.5: Test online status TTL: Wait 30 seconds, verify status updates
- [ ] 8.6: Test LRU eviction: Load 150 users, verify cache size = 100
- [ ] 8.7: Document validation results in Dev Agent Record

### Task 9: Add Firestore Listener Cleanup Validation (AC: 5)
- [ ] 9.1: Review all ViewModels using `observeMessages()` or `observeConversations()`
- [ ] 9.2: Verify `cancellables` storage for all listeners
- [ ] 9.3: Add `deinit` methods with cleanup logging
- [ ] 9.4: Run app with Xcode Instruments (Leaks tool)
- [ ] 9.5: Navigate between views 10+ times
- [ ] 9.6: Verify no memory leaks in Leaks tool
- [ ] 9.7: Document validation in Dev Agent Record

### Task 10: Integrate Network Retry Policy into Repositories (AC: 6)
- [ ] 10.1: Update `FirebaseMessageRepository.sendMessage()` with retry logic
- [ ] 10.2: Update `FirebaseConversationRepository.createConversation()` with retry logic
- [ ] 10.3: Update `FirebaseUserRepository.updateUser()` with retry logic
- [ ] 10.4: Write unit test: `testMessageSend_RetriesOnNetworkError()`
- [ ] 10.5: Manual test: Simulate network failure, verify retry logs

### Task 11: Add Timeout Handling (AC: 7)
- [ ] 11.1: Wrap Firebase operations with `Task.timeout(seconds: 10)`
- [ ] 11.2: Handle timeout errors with user-friendly messages
- [ ] 11.3: Write unit test: `testMessageSend_TimesOutAfter10Seconds()`
- [ ] 11.4: Write unit test: `testTimeout_ShowsUserFriendlyError()`

### Task 12: Create Performance Baseline Tests (AC: 10, 11)
- [ ] 12.1: Create `MessageAITests/Performance/PerformanceBaselineTests.swift`
- [ ] 12.2: Implement `testAppLaunchTime()` - < 1 second
- [ ] 12.3: Implement `testConversationLoadTime()` - < 1 second
- [ ] 12.4: Implement `testMessageSendTime()` - < 2 seconds
- [ ] 12.5: Implement `testMemoryUsageWith10Conversations()` - < 150MB
- [ ] 12.6: Implement `getMemoryUsage()` helper using mach_task_basic_info
- [ ] 12.7: Run performance tests: `xcodebuild test -only-testing:PerformanceBaselineTests`
- [ ] 12.8: Document baseline results in Dev Agent Record

### Task 13: Integration Testing - Rapid-Fire Messaging (AC: 9)
- [ ] 13.1: Requires Firebase Emulator running
- [ ] 13.2: Create test: Send 20 messages in < 5 seconds
- [ ] 13.3: Verify all 20 messages delivered
- [ ] 13.4: Verify messages in correct order (timestamps ascending)
- [ ] 13.5: Verify no duplicates
- [ ] 13.6: Verify no crashes

### Task 14: Integration Testing - Offline/Online Transition (AC: 13, 15)
- [ ] 14.1: Requires Firebase Emulator running
- [ ] 14.2: Create test: Start online, send 5 messages
- [ ] 14.3: Toggle airplane mode (offline)
- [ ] 14.4: Send 5 messages (queued)
- [ ] 14.5: Toggle airplane mode (online)
- [ ] 14.6: Verify all 10 messages delivered
- [ ] 14.7: Repeat toggle 5 times, verify no data loss

### Task 15: Integration Testing - Large Dataset (AC: 16)
- [ ] 15.1: Requires Firebase Emulator running
- [ ] 15.2: Create conversation with 1000 messages
- [ ] 15.3: Open ChatView
- [ ] 15.4: Verify initial 50 messages load
- [ ] 15.5: Scroll to top repeatedly, load all 1000 messages
- [ ] 15.6: Verify smooth scrolling (no lag)
- [ ] 15.7: Verify memory usage < 150MB

### Task 16: Manual Testing - 3G Network Simulation (AC: 8)
- [ ] 16.1: Enable Network Link Conditioner (3G profile)
- [ ] 16.2: Send 10 messages
- [ ] 16.3: Verify all messages delivered (slower, but no crashes)
- [ ] 16.4: Verify retry logic kicks in on timeouts
- [ ] 16.5: Verify optimistic UI shows messages immediately
- [ ] 16.6: Disable Network Link Conditioner

### Task 17: Manual Testing - Battery Usage (AC: 12)
- [ ] 17.1: Use Xcode Instruments (Energy Log tool)
- [ ] 17.2: Run app for 10 minutes with active messaging
- [ ] 17.3: Verify no background processing runaway
- [ ] 17.4: Verify listeners paused when app backgrounded
- [ ] 17.5: Document energy usage report

### Task 18: Regression Testing (AC: 19)
- [ ] 18.1: Run story-level tests: `./scripts/test-story.sh ChatViewModelTests`
- [ ] 18.2: Run epic-level tests: `./scripts/test-epic.sh 2`
- [ ] 18.3: Run full test suite: `./scripts/quick-test.sh`
- [ ] 18.4: Verify all previous stories still work correctly
- [ ] 18.5: Verify message sending, editing, deletion still work
- [ ] 18.6: Verify offline queue still works
- [ ] 18.7: Verify push notifications still work

---

## Testing

### Unit Tests Required (20-25 tests)

**File:** `MessageAITests/Data/Network/NetworkRetryPolicyTests.swift`
1. `testExponentialBackoffDelays()` - Verify 1s, 2s, 4s delays
2. `testRetrySucceedsAfterFailure()` - Retry succeeds on 2nd attempt
3. `testRetryThrowsAfterMaxAttempts()` - Throws after 3 failures
4. `testTimeoutEnforced()` - Operation times out after 10 seconds

**File:** `MessageAITests/Presentation/ViewModels/ChatViewModelPaginationTests.swift`
5. `testLoadMoreMessages_LoadsOlderMessages()` - Verify older messages loaded
6. `testLoadMoreMessages_SetsHasMoreFalse_WhenEndReached()` - Verify end detection
7. `testLoadMoreMessages_PreventsConcurrentLoads()` - Only one load at a time
8. `testMessagePagination_Loads50MessagesInitially()` - Verify page size
9. `testMessagePagination_LoadsNext50OnScroll()` - Verify next page

**File:** `MessageAITests/Presentation/ViewModels/ConversationsListViewModelPaginationTests.swift`
10. `testLoadMoreConversations_LoadsOlderConversations()` - Verify older convos loaded
11. `testConversationPagination_HandlesLargeDataset()` - 100+ conversations
12. `testConversationPagination_Loads50Initially()` - Verify page size

**File:** `MessageAITests/Presentation/Utils/RelativeTimestampFormatterTests.swift`
13. `testRelativeTimestampFormatting_Now()` - < 1 minute
14. `testRelativeTimestampFormatting_MinutesAgo()` - "5m ago"
15. `testRelativeTimestampFormatting_HoursAgo()` - "3h ago"
16. `testRelativeTimestampFormatting_Yesterday()` - "Yesterday"
17. `testRelativeTimestampFormatting_LastWeek()` - "Jan 15"

**File:** `MessageAITests/Presentation/ViewModels/ConversationsListViewModelTests.swift` (UPDATE)
18. `testTimestampUpdatesEvery60Seconds()` - Timer triggers update
19. `testTimestampUpdatesStop_WhenViewDisappears()` - Timer cancelled

**File:** `MessageAITests/Data/Repositories/FirebaseMessageRepositoryTests.swift` (UPDATE)
20. `testMessageSend_RetriesOnNetworkError()` - Retry logic works
21. `testMessageSend_TimesOutAfter10Seconds()` - Timeout enforced

### Performance Tests (NEW)

**File:** `MessageAITests/Performance/PerformanceBaselineTests.swift`
22. `testAppLaunchTime()` - < 1 second (AC #10)
23. `testConversationLoadTime()` - < 1 second (AC #10)
24. `testMessageSendTime()` - < 2 seconds (AC #10)
25. `testMemoryUsageWith10Conversations()` - < 150MB (AC #11)

### Integration Tests (Firebase Emulator Required)

**File:** `MessageAITests/Integration/PerformanceIntegrationTests.swift`
1. `testRapidFireMessaging_20Messages()` - AC #9
2. `testOfflineOnlineTransition_NoDataLoss()` - AC #13, #15
3. `testLargeDatasetLoad_1000Messages()` - AC #16

### Manual Testing Checklist

**Performance Baselines (AC #10):**
- [ ] App launch < 1 second (measure with Xcode)
- [ ] Conversation load < 1 second (measure with console logs)
- [ ] Message send < 2 seconds (measure end-to-end)

**Memory Profiling (AC #11):**
- [ ] Open Xcode Instruments (Allocations tool)
- [ ] Load 10 conversations with messages
- [ ] Verify memory usage < 150MB
- [ ] Navigate between views, verify no leaks

**3G Network Simulation (AC #8):**
- [ ] Enable Network Link Conditioner (3G profile)
- [ ] Send 10 messages
- [ ] Verify no crashes or data loss
- [ ] Verify retry logic works

**Battery Usage (AC #12):**
- [ ] Open Xcode Instruments (Energy Log tool)
- [ ] Run app for 10 minutes
- [ ] Verify no runaway background processing
- [ ] Verify reasonable energy usage

**Rapid-Fire Messaging (AC #9):**
- [ ] Send 20+ messages quickly (< 5 seconds)
- [ ] Verify all delivered
- [ ] Verify correct order
- [ ] Verify no duplicates

**Offline/Online Transition (AC #13):**
- [ ] Start online, send messages
- [ ] Toggle airplane mode repeatedly
- [ ] Verify no crashes
- [ ] Verify queued messages process smoothly

**Large Dataset (AC #16):**
- [ ] Load conversation with 1000+ messages
- [ ] Verify smooth scrolling
- [ ] Verify pagination works
- [ ] Verify memory usage acceptable

**Relative Timestamps (AC #14):**
- [ ] Open conversations list
- [ ] Wait 1 minute
- [ ] Verify timestamps update ("2m ago" → "3m ago")
- [ ] Verify no flickering
- [ ] Background app, verify timer pauses

**User Cache Validation (AC #17):**
- [ ] Edit message in conversation
- [ ] Check console logs
- [ ] Verify 0-1 user fetches (not 50+)
- [ ] Wait 5 minutes
- [ ] Change profile in Firebase Console
- [ ] Verify change appears within 5 minutes

---

## Complexity & Time Estimate

**Complexity:** High
**Estimated Time:** 6-8 hours
**Risk Level:** Medium

**Breakdown:**
- Composite indexes setup: 30 minutes
- Network retry policy: 1 hour
- Message pagination: 2 hours
- Conversation pagination: 1.5 hours
- Relative timestamp updates: 1 hour
- Performance baseline tests: 1.5 hours
- Integration testing: 1 hour
- Manual testing & validation: 1.5 hours

**Risks:**
- Firestore composite indexes may take time to build (5-10 minutes)
- Performance baselines may fail initially (require optimization iteration)
- Large dataset testing requires Firebase Emulator setup
- Memory profiling with Instruments can be time-consuming

---

## Dependencies

**Blocks:** Story 2.12 (Comprehensive Reliability Testing)
**Blocked By:** All Epic 2 stories (Story 2.0-2.10a must be complete)
**External:** Firebase Emulator for integration tests

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Story created - Performance Optimization & Network Resilience | Bob (SM) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

---

## QA Results

*This section will be populated by QA agent after implementation.*
