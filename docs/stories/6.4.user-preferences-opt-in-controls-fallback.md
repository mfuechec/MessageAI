# Story 6.4: User Preferences, Opt-In Controls & Fallback

## Status

**Draft**

---

## Story

**As a** user,
**I want** to control smart notification settings and provide explicit consent,
**so that** I maintain privacy and can customize notification behavior to my needs.

---

## Prerequisites

**IMPORTANT:** This story defines the `NotificationPreferences` schema used by Stories 6.2, 6.3, and 6.6.

**Implementation Order:** Implement this story BEFORE (or in parallel with) Stories 6.2 and 6.3.

---

## Acceptance Criteria

**Opt-In Flow:**
1. New settings section: "Smart Notifications (AI-Powered)" in app Settings
2. First-time setup: Modal explaining feature when user opens settings
3. Modal content:
   - "Let AI analyze your conversations to reduce notification fatigue"
   - "Only get notified about messages that matter to you"
   - "AI considers mentions, urgent requests, and context"
   - "You can disable this anytime"
4. Explicit opt-in required: "Enable Smart Notifications" button
5. Opt-in saves preference to Firestore: `users/{userId}/ai_notification_preferences/enabled = true`

**Privacy & Consent:**
6. Privacy statement in modal: "Your messages are analyzed securely. We don't store message content, only notification decisions."
7. Link to privacy policy
8. User can opt-out anytime (disable feature, revert to standard notifications)
9. Opt-out confirmation: "Are you sure? You'll receive notifications for every message."

**Notification Preferences UI:**
10. Setting: Enable/Disable Smart Notifications (toggle)
11. Setting: Pause threshold slider (60s - 300s, default 120s)
12. Setting: Active conversation message threshold (10-50 messages, default 20)
13. Setting: Quiet hours (start time, end time, timezone) - suppress non-urgent notifications
14. Setting: Priority keywords (user-customizable list, default: "urgent", "ASAP", "production", "down", "blocker")
15. Setting: Max analyses per hour (5-20, default 10) - cost control

**Fallback Strategy:**
16. Setting: "If AI is unavailable" dropdown with options:
    - "Use simple rules (mentions, keywords)" [Default]
    - "Notify for all messages" (traditional behavior)
    - "No notifications" (suppresses notifications entirely)
17. Fallback preference stored in Firestore, used when Cloud Function fails
18. Fallback status displayed in settings: "AI Status: ✅ Active" or "⚠️ Using Fallback (AI unavailable)"

**Testing Preferences:**
19. Button: "Test Smart Notification" - calls `analyzeForNotification` with user's most recent conversation
20. Test result modal shows:
    - Decision: "✅ Will Notify" or "❌ Won't Notify"
    - Priority: high/medium/low badge
    - Reason: AI reasoning text
    - Notification text: Generated notification text
    - Note: "This is a test - no actual notification sent"
21. Helps users understand AI decision-making logic
22. Error handling: If test fails (no recent conversations, AI error), show user-friendly message: "No recent conversations to test" or "AI temporarily unavailable"

**Real-Time Preference Updates:**
23. Preferences sync via Firestore snapshot listener
24. Changes take effect immediately (no app restart required)
25. Cloud Function reads latest preferences on each analysis call

**Default Preferences:**
26. On first opt-in, create default preferences:
    - enabled: true
    - pauseThresholdSeconds: 120
    - activeConversationThreshold: 20
    - quietHoursStart: "22:00"
    - quietHoursEnd: "08:00"
    - priorityKeywords: ["urgent", "ASAP", "production down", "blocker", "help"]
    - maxAnalysesPerHour: 10
    - fallbackStrategy: "simple_rules"

**Testing:**
27. Unit test: Opt-in flow sets correct Firestore values
28. Unit test: Preference changes update Firestore
29. Unit test: Default preferences created correctly
30. Integration test: Quiet hours suppress notifications correctly
31. Integration test: Priority keywords trigger notifications
32. Integration test: Fallback strategy used when AI unavailable
33. UI test: Settings UI displays current preferences accurately
34. UI test: Test notification button shows correct analysis result
35. UI test: Test notification error handling works (no conversations, AI failure)

---

## Tasks / Subtasks

- [ ] Create NotificationPreferences entity (AC: 25)
  - [ ] Create `Domain/Entities/NotificationPreferences.swift`
  - [ ] Define all preference fields with defaults
  - [ ] Add Codable conformance for Firestore serialization
  - [ ] Create FallbackStrategy enum: `.simpleRules`, `.notifyAll`, `.suppressAll`

- [ ] Create opt-in modal UI (AC: 1-5)
  - [ ] Create `SmartNotificationOnboardingView.swift` in Presentation/Views/Settings
  - [ ] Design modal with feature explanation
  - [ ] Add "Enable Smart Notifications" button
  - [ ] Add "Maybe Later" button (dismisses modal)
  - [ ] Show modal on first visit to Settings > Notifications section

- [ ] Add privacy & consent UI (AC: 6-9)
  - [ ] Add privacy statement text to modal
  - [ ] Add "Learn More" link to privacy policy (web view or external link)
  - [ ] Implement opt-out flow with confirmation dialog
  - [ ] Update Firestore on opt-out: `enabled = false`

- [ ] Create notification preferences settings screen (AC: 10-15)
  - [ ] Create `SmartNotificationSettingsView.swift`
  - [ ] Add toggle: Enable/Disable Smart Notifications
  - [ ] Add slider: Pause threshold (60-300 seconds)
  - [ ] Add slider: Active conversation threshold (10-50 messages)
  - [ ] Add time pickers: Quiet hours start/end
  - [ ] Add text field list: Priority keywords (add/remove)
  - [ ] Add stepper: Max analyses per hour (5-20)

- [ ] Create fallback strategy settings (AC: 16-18)
  - [ ] Add dropdown/picker: Fallback strategy selection
  - [ ] Add status indicator: "AI Status: ✅ Active" / "⚠️ Using Fallback"
  - [ ] Query Cloud Function health endpoint to determine status
  - [ ] Update status indicator in real-time

- [ ] Implement test notification feature (AC: 19-21)
  - [ ] Add "Test Smart Notification" button in settings
  - [ ] Call `analyzeForNotification` Cloud Function with most recent conversation
  - [ ] Show result modal with: shouldNotify, reason, notificationText, priority
  - [ ] Add "This helps!" / "Needs improvement" feedback buttons (Story 6.5 integration)

- [ ] Create NotificationPreferencesViewModel (AC: 22-24)
  - [ ] Create ViewModel in `Presentation/ViewModels/`
  - [ ] Add @Published properties for all preferences
  - [ ] Implement Firestore snapshot listener for real-time sync
  - [ ] Add save method: `savePreferences() async throws`
  - [ ] Add load method: `loadPreferences() async throws`

- [ ] Implement Firestore integration
  - [ ] Create `NotificationPreferencesRepository` protocol in Domain
  - [ ] Create `FirebaseNotificationPreferencesRepository` in Data
  - [ ] Implement CRUD operations for preferences
  - [ ] Add snapshot listener for real-time updates

- [ ] Set default preferences on opt-in (AC: 25)
  - [ ] Create default preferences object
  - [ ] Save to Firestore on "Enable Smart Notifications" tap
  - [ ] Verify defaults are correct

- [ ] Integrate with DIContainer
  - [ ] Add factory method: `makeNotificationPreferencesViewModel()`
  - [ ] Add factory method: `makeNotificationPreferencesRepository()`
  - [ ] Wire up dependencies

- [ ] Write unit tests (AC: 26-27)
  - [ ] Test: Opt-in sets enabled=true in Firestore
  - [ ] Test: Opt-out sets enabled=false
  - [ ] Test: Preference changes save to Firestore
  - [ ] Test: Default preferences created correctly
  - [ ] Test: ViewModel loads preferences from repository

- [ ] Write integration tests (AC: 28-30)
  - [ ] Test: Quiet hours suppress notifications (call Cloud Function during quiet hours)
  - [ ] Test: Priority keywords trigger notifications
  - [ ] Test: Fallback strategy used when AI unavailable (mock Cloud Function failure)

- [ ] Write UI tests (AC: 31-32)
  - [ ] Test: Settings UI displays current preferences
  - [ ] Test: Toggle switches update ViewModel
  - [ ] Test: Sliders update ViewModel
  - [ ] Test: Test notification button shows result

---

## Dev Notes

### Architecture Context

**MVVM Pattern:**
```
SmartNotificationSettingsView (SwiftUI)
  ↓ @StateObject
NotificationPreferencesViewModel (@MainActor, ObservableObject)
  ↓ Uses
NotificationPreferencesRepositoryProtocol (Domain)
  ↓ Implemented by
FirebaseNotificationPreferencesRepository (Data)
  ↓ Writes to
Firestore: users/{userId}/ai_notification_preferences
```

**Real-Time Sync:**
```
Firestore snapshot listener → Repository → ViewModel (@Published) → SwiftUI View (auto-update)
```

### Relevant Source Tree

**New Files:**
- `MessageAI/Domain/Entities/NotificationPreferences.swift`
- `MessageAI/Domain/Repositories/NotificationPreferencesRepositoryProtocol.swift`
- `MessageAI/Data/Repositories/FirebaseNotificationPreferencesRepository.swift`
- `MessageAI/Presentation/ViewModels/NotificationPreferencesViewModel.swift`
- `MessageAI/Presentation/Views/Settings/SmartNotificationOnboardingView.swift`
- `MessageAI/Presentation/Views/Settings/SmartNotificationSettingsView.swift`
- `MessageAITests/Presentation/ViewModels/NotificationPreferencesViewModelTests.swift`

**Modified Files:**
- `MessageAI/Presentation/Views/Settings/SettingsView.swift` - Add link to Smart Notifications section
- `MessageAI/App/DIContainer.swift` - Add factory methods

### Key Technical Decisions

**1. NotificationPreferences Entity:**
```swift
// Domain/Entities/NotificationPreferences.swift
struct NotificationPreferences: Codable, Equatable {
    let userId: String
    var enabled: Bool
    var pauseThresholdSeconds: Int // 60-300
    var activeConversationThreshold: Int // 10-50
    var quietHoursStart: String // "22:00"
    var quietHoursEnd: String // "08:00"
    var timezone: String // "America/Los_Angeles"
    var priorityKeywords: [String]
    var maxAnalysesPerHour: Int // 5-20
    var fallbackStrategy: FallbackStrategy
    var createdAt: Date
    var updatedAt: Date

    static var `default`: NotificationPreferences {
        NotificationPreferences(
            userId: "",
            enabled: true,
            pauseThresholdSeconds: 120,
            activeConversationThreshold: 20,
            quietHoursStart: "22:00",
            quietHoursEnd: "08:00",
            timezone: TimeZone.current.identifier,
            priorityKeywords: ["urgent", "ASAP", "production down", "blocker", "help"],
            maxAnalysesPerHour: 10,
            fallbackStrategy: .simpleRules,
            createdAt: Date(),
            updatedAt: Date()
        )
    }
}

enum FallbackStrategy: String, Codable {
    case simpleRules = "simple_rules"
    case notifyAll = "notify_all"
    case suppressAll = "suppress_all"
}
```

**2. ViewModel Pattern:**
```swift
@MainActor
class NotificationPreferencesViewModel: ObservableObject {
    @Published var preferences: NotificationPreferences
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var aiStatus: AIStatus = .active

    private let repository: NotificationPreferencesRepositoryProtocol
    private var cancellables = Set<AnyCancellable>()

    init(repository: NotificationPreferencesRepositoryProtocol, userId: String) {
        self.repository = repository
        self.preferences = .default
        self.preferences.userId = userId

        // Set up real-time listener
        setupRealtimeListener()
    }

    func loadPreferences() async {
        isLoading = true
        do {
            preferences = try await repository.getPreferences(userId: preferences.userId)
        } catch {
            errorMessage = "Failed to load preferences: \(error.localizedDescription)"
        }
        isLoading = false
    }

    func savePreferences() async {
        preferences.updatedAt = Date()
        do {
            try await repository.savePreferences(preferences)
        } catch {
            errorMessage = "Failed to save preferences: \(error.localizedDescription)"
        }
    }

    func testNotification() async {
        // Call analyzeForNotification with recent conversation
        // Show result in modal
    }

    private func setupRealtimeListener() {
        repository.observePreferences(userId: preferences.userId)
            .sink { [weak self] updatedPreferences in
                self?.preferences = updatedPreferences
            }
            .store(in: &cancellables)
    }
}

enum AIStatus {
    case active
    case usingFallback
    case unavailable
}
```

**3. SwiftUI Settings View:**
```swift
struct SmartNotificationSettingsView: View {
    @StateObject var viewModel: NotificationPreferencesViewModel
    @State private var showTestResult = false
    @State private var testDecision: NotificationDecision?

    var body: some View {
        Form {
            Section("Smart Notifications") {
                Toggle("Enabled", isOn: $viewModel.preferences.enabled)
                    .onChange(of: viewModel.preferences.enabled) { _ in
                        Task { await viewModel.savePreferences() }
                    }

                HStack {
                    Text("AI Status")
                    Spacer()
                    statusIndicator(viewModel.aiStatus)
                }
            }

            Section("Trigger Settings") {
                VStack(alignment: .leading) {
                    Text("Pause Threshold: \(viewModel.preferences.pauseThresholdSeconds)s")
                    Slider(value: .init(
                        get: { Double(viewModel.preferences.pauseThresholdSeconds) },
                        set: { viewModel.preferences.pauseThresholdSeconds = Int($0) }
                    ), in: 60...300, step: 30)
                }

                VStack(alignment: .leading) {
                    Text("Message Threshold: \(viewModel.preferences.activeConversationThreshold)")
                    Slider(value: .init(
                        get: { Double(viewModel.preferences.activeConversationThreshold) },
                        set: { viewModel.preferences.activeConversationThreshold = Int($0) }
                    ), in: 10...50, step: 5)
                }
            }

            Section("Quiet Hours") {
                DatePicker("Start", selection: quietHoursStartBinding, displayedComponents: .hourAndMinute)
                DatePicker("End", selection: quietHoursEndBinding, displayedComponents: .hourAndMinute)
            }

            Section("Priority Keywords") {
                ForEach(viewModel.preferences.priorityKeywords, id: \.self) { keyword in
                    Text(keyword)
                }
                .onDelete { offsets in
                    viewModel.preferences.priorityKeywords.remove(atOffsets: offsets)
                    Task { await viewModel.savePreferences() }
                }
                Button("Add Keyword") {
                    // Show text input dialog
                }
            }

            Section("Fallback Strategy") {
                Picker("If AI Unavailable", selection: $viewModel.preferences.fallbackStrategy) {
                    Text("Use Simple Rules").tag(FallbackStrategy.simpleRules)
                    Text("Notify All Messages").tag(FallbackStrategy.notifyAll)
                    Text("Suppress All").tag(FallbackStrategy.suppressAll)
                }
            }

            Section("Testing") {
                Button("Test Smart Notification") {
                    Task {
                        testDecision = await viewModel.testNotification()
                        showTestResult = true
                    }
                }
            }
        }
        .navigationTitle("Smart Notifications")
        .sheet(isPresented: $showTestResult) {
            TestResultView(decision: testDecision)
        }
    }

    private func statusIndicator(_ status: AIStatus) -> some View {
        switch status {
        case .active:
            return Label("Active", systemImage: "checkmark.circle.fill")
                .foregroundColor(.green)
        case .usingFallback:
            return Label("Using Fallback", systemImage: "exclamationmark.triangle.fill")
                .foregroundColor(.orange)
        case .unavailable:
            return Label("Unavailable", systemImage: "xmark.circle.fill")
                .foregroundColor(.red)
        }
    }
}
```

**4. Onboarding Modal:**
```swift
struct SmartNotificationOnboardingView: View {
    @Environment(\.dismiss) var dismiss
    let onEnable: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "brain.head.profile")
                .font(.system(size: 60))
                .foregroundColor(.blue)

            Text("Smart Notifications")
                .font(.title)
                .bold()

            Text("Let AI analyze your conversations to reduce notification fatigue")
                .multilineTextAlignment(.center)

            VStack(alignment: .leading, spacing: 10) {
                FeatureRow(icon: "checkmark", text: "Only get notified about messages that matter")
                FeatureRow(icon: "checkmark", text: "AI considers mentions, urgent requests, and context")
                FeatureRow(icon: "checkmark", text: "You can disable this anytime")
            }
            .padding()

            Text("Your messages are analyzed securely. We don't store message content, only notification decisions.")
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            Button("Enable Smart Notifications") {
                onEnable()
                dismiss()
            }
            .buttonStyle(.borderedProminent)

            Button("Maybe Later") {
                dismiss()
            }
            .buttonStyle(.bordered)

            Link("Privacy Policy", destination: URL(string: "https://example.com/privacy")!)
                .font(.caption)
        }
        .padding()
    }
}

struct FeatureRow: View {
    let icon: String
    let text: String

    var body: some View {
        HStack {
            Image(systemName: icon + ".circle.fill")
                .foregroundColor(.green)
            Text(text)
        }
    }
}
```

**5. Firestore Real-Time Listener:**
```swift
func observePreferences(userId: String) -> AnyPublisher<NotificationPreferences, Never> {
    let subject = PassthroughSubject<NotificationPreferences, Never>()

    let listener = db.collection("users").document(userId)
        .collection("ai_notification_preferences")
        .document("preferences")
        .addSnapshotListener { snapshot, error in
            guard let data = snapshot?.data() else { return }
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: data)
                let preferences = try JSONDecoder().decode(NotificationPreferences.self, from: jsonData)
                subject.send(preferences)
            } catch {
                print("Error decoding preferences: \(error)")
            }
        }

    return subject.handleEvents(receiveCancel: {
        listener.remove()
    }).eraseToAnyPublisher()
}
```

### Testing Standards

**Test File Location:**
- Unit tests: `MessageAITests/Presentation/ViewModels/NotificationPreferencesViewModelTests.swift`
- Integration tests: `MessageAITests/Integration/NotificationPreferencesIntegrationTests.swift`
- UI tests: `MessageAIUITests/Settings/SmartNotificationSettingsUITests.swift`

**Testing Frameworks:**
- XCTest for unit and integration tests
- SwiftUI Preview for UI iteration
- Firebase Emulator for integration tests

**Test Coverage Requirements:**
- NotificationPreferencesViewModel: 80%+ coverage
- Repository: 70%+ coverage
- UI Tests: Cover all critical flows (opt-in, opt-out, preference changes)

**Testing Patterns:**
```swift
class NotificationPreferencesViewModelTests: XCTestCase {
    var mockRepository: MockNotificationPreferencesRepository!
    var viewModel: NotificationPreferencesViewModel!

    override func setUp() {
        mockRepository = MockNotificationPreferencesRepository()
        viewModel = NotificationPreferencesViewModel(
            repository: mockRepository,
            userId: "user123"
        )
    }

    func testLoadPreferences() async throws {
        // Given: Repository has preferences
        let preferences = NotificationPreferences.default
        mockRepository.preferencesResult = .success(preferences)

        // When: Load preferences
        await viewModel.loadPreferences()

        // Then: Preferences loaded
        XCTAssertEqual(viewModel.preferences, preferences)
        XCTAssertFalse(viewModel.isLoading)
    }

    func testSavePreferences() async throws {
        // Given: Updated preferences
        viewModel.preferences.pauseThresholdSeconds = 180

        // When: Save preferences
        await viewModel.savePreferences()

        // Then: Repository called with updated preferences
        XCTAssertTrue(mockRepository.saveWasCalled)
        XCTAssertEqual(mockRepository.lastSavedPreferences?.pauseThresholdSeconds, 180)
    }
}
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
