# Story 2.4: Message Send Retry on Failure

## Status

**Approved**

---

## Story

**As a** user,  
**I want** to manually retry sending messages that failed,  
**so that** I have control over when failed messages are resent.

---

## Acceptance Criteria

1. Messages that fail to send display with red warning icon and "Failed" status
2. Tap failed message shows alert: "Message failed to send. [Retry] [Delete]"
3. Retry button attempts to resend message via repository
4. Delete button removes message from local queue permanently
5. Failed messages persist locally (not lost on app restart)
6. Message status enum includes: sending, sent, delivered, read, failed
7. ViewModel tracks failed messages and provides retry action
8. Performance: Retry attempt completes within 3 seconds or marks failed again
9. Reliability: Failed messages stored in local queue, never lost
10. Network error types handled gracefully (timeout, no connection, Firebase error)
11. Unit tests for retry logic in ViewModel
12. Integration test: Force network failure, send message, verify failure state, restore network, retry, verify success
13. Regression test: Normal message sending still works reliably

---

## Previous Story Context (Story 2.3 Completion)

### Key Learnings from Story 2.3

**Message Deletion Complete:**
- Soft delete pattern with isDeleted flag
- Privacy compliance (text removed from Firestore)
- 24-hour time window enforcement
- Conversation lastMessage updates working

**ChatViewModel Patterns:**
- Optimistic UI: Update local state, call repository async, rollback on failure
- Array reassignment: `var updated = messages; messages = updated` triggers @Published
- Error handling: RepositoryError â†’ user-friendly messages
- MessageKit tap gesture for custom actions

**What This Means for Story 2.4:**
- Can build on existing error handling in sendMessage()
- Array manipulation patterns established
- Need to change current behavior: Instead of removing failed message, keep it with .failed status
- Add retry and delete actions via alert

---

## Dev Notes

### What's Already Done (From Epic 1)

**Message Entity & Status Enum** âœ…

`MessageStatus` enum already includes `.failed` status:

```swift
// MessageAI/Domain/Entities/MessageStatus.swift
enum MessageStatus: String, Codable {
    case sending
    case sent
    case delivered
    case read
    case failed  // â† Already exists! (AC #6 âœ…)
    
    var sortOrder: Int {
        switch self {
        case .sending: return 0
        case .failed: return 0  // Same as sending (can retry)
        case .sent: return 1
        case .delivered: return 2
        case .read: return 3
        }
    }
    
    func canTransitionTo(_ newStatus: MessageStatus) -> Bool {
        return newStatus.sortOrder >= self.sortOrder
    }
}
```

**Message Entity:**

```swift
// MessageAI/Domain/Entities/Message.swift
struct Message: Codable, Equatable, Identifiable {
    let id: String
    let conversationId: String
    let senderId: String
    var text: String
    let timestamp: Date
    var status: MessageStatus  // â† Already tracks status
    var statusUpdatedAt: Date
    // ... other fields
}
```

**Current ChatViewModel sendMessage() Behavior:**

Lines 170-235 of ChatViewModel.swift:
1. Creates message with `.sending` status
2. Appends to messages array (optimistic UI)
3. Calls `messageRepository.sendMessage(message)`
4. On success: updates status to `.sent`
5. On failure: **REMOVES message from array** â† Story 2.4 changes this

---

### What's NEW in Story 2.4

**Story 2.4 Changes Focus:**

#### 1. Change Error Handling in sendMessage()

**Current Behavior (Lines 229-234):**

```swift
} catch {
    // On failure: remove optimistic message, show error
    messages.removeAll { $0.id == message.id }
    errorMessage = "Failed to send message: \(error.localizedDescription)"
    print("Error sending message: \(error)")
}
```

**NEW Behavior (Story 2.4):**

```swift
} catch {
    // On failure: mark message as failed, keep in array
    if let index = messages.firstIndex(where: { $0.id == message.id }) {
        var failedMessage = messages[index]
        failedMessage.status = .failed
        failedMessage.statusUpdatedAt = Date()
        
        // Reassign array to trigger @Published
        var updated = messages
        updated[index] = failedMessage
        messages = updated
    }
    
    // Save failed message to local persistence
    saveFailedMessageLocally(message)
    
    // Show user-friendly error
    errorMessage = mapErrorToUserMessage(error)
    print("âŒ Message failed: \(error)")
}
```

---

#### 2. Local Persistence for Failed Messages

**File:** `MessageAI/Data/Persistence/FailedMessageStore.swift` (NEW)

```swift
import Foundation

/// Local persistence for failed messages (survives app restart)
class FailedMessageStore {
    private let userDefaults = UserDefaults.standard
    private let key = "failedMessages"
    
    /// Save failed message to UserDefaults
    func save(_ message: Message) {
        var failedMessages = loadAll()
        
        // Add or update message
        if let index = failedMessages.firstIndex(where: { $0.id == message.id }) {
            failedMessages[index] = message
        } else {
            failedMessages.append(message)
        }
        
        // Encode and save
        if let encoded = try? JSONEncoder().encode(failedMessages) {
            userDefaults.set(encoded, forKey: key)
            print("ğŸ’¾ Saved failed message: \(message.id)")
        }
    }
    
    /// Load all failed messages from UserDefaults
    func loadAll() -> [Message] {
        guard let data = userDefaults.data(forKey: key),
              let messages = try? JSONDecoder().decode([Message].self, from: data) else {
            return []
        }
        return messages
    }
    
    /// Remove failed message after successful retry or delete
    func remove(_ messageId: String) {
        var failedMessages = loadAll()
        failedMessages.removeAll { $0.id == messageId }
        
        if let encoded = try? JSONEncoder().encode(failedMessages) {
            userDefaults.set(encoded, forKey: key)
            print("ğŸ—‘ï¸ Removed failed message: \(messageId)")
        }
    }
    
    /// Clear all failed messages (for testing)
    func clearAll() {
        userDefaults.removeObject(forKey: key)
    }
}
```

---

#### 3. Add Retry and Delete Actions to ChatViewModel

**File:** `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift`

Add new properties:

```swift
@MainActor
class ChatViewModel: ObservableObject {
    // ... existing properties ...
    
    // Failed message handling
    private let failedMessageStore = FailedMessageStore()
    @Published var retryingMessageId: String?  // Track retry in progress
}
```

Add retry method:

```swift
/// Retry sending a failed message
func retryMessage(_ message: Message) async {
    guard message.status == .failed else {
        print("âš ï¸ Cannot retry message that isn't failed")
        return
    }
    
    print("ğŸ”„ Retrying message: \(message.id)")
    retryingMessageId = message.id
    defer { retryingMessageId = nil }
    
    // 1. Update status to .sending
    if let index = messages.firstIndex(where: { $0.id == message.id }) {
        var retryingMessage = messages[index]
        retryingMessage.status = .sending
        retryingMessage.statusUpdatedAt = Date()
        
        var updated = messages
        updated[index] = retryingMessage
        messages = updated
    }
    
    // 2. Attempt to send
    do {
        try await messageRepository.sendMessage(message)
        
        // Success: Update status to .sent
        if let index = messages.firstIndex(where: { $0.id == message.id }) {
            var sentMessage = messages[index]
            sentMessage.status = .sent
            sentMessage.statusUpdatedAt = Date()
            
            var updated = messages
            updated[index] = sentMessage
            messages = updated
        }
        
        // Remove from failed messages store
        failedMessageStore.remove(message.id)
        
        // Update conversation
        try await updateConversation(with: message)
        
        print("âœ… Retry successful: \(message.id)")
        
    } catch {
        // Retry failed: Mark as failed again
        if let index = messages.firstIndex(where: { $0.id == message.id }) {
            var failedMessage = messages[index]
            failedMessage.status = .failed
            failedMessage.statusUpdatedAt = Date()
            
            var updated = messages
            updated[index] = failedMessage
            messages = updated
        }
        
        errorMessage = mapErrorToUserMessage(error)
        print("âŒ Retry failed: \(error)")
    }
}

/// Delete a failed message permanently
func deleteFailedMessage(_ message: Message) {
    print("ğŸ—‘ï¸ Deleting failed message: \(message.id)")
    
    // Remove from messages array
    messages.removeAll { $0.id == message.id }
    
    // Remove from local persistence
    failedMessageStore.remove(message.id)
    
    print("âœ… Failed message deleted")
}

/// Load failed messages from local persistence on init
private func loadFailedMessages() {
    let failedMessages = failedMessageStore.loadAll()
    
    if !failedMessages.isEmpty {
        print("ğŸ’¾ Loaded \(failedMessages.count) failed message(s) from local storage")
        
        // Add to messages array if not already present
        for failedMessage in failedMessages {
            if !messages.contains(where: { $0.id == failedMessage.id }) {
                messages.append(failedMessage)
            }
        }
        
        // Sort by timestamp
        messages.sort { $0.timestamp < $1.timestamp }
    }
}

/// Helper: Map error to user-friendly message
private func mapErrorToUserMessage(_ error: Error) -> String {
    if let repoError = error as? RepositoryError {
        switch repoError {
        case .networkError:
            return "No internet connection. Message will be saved and you can retry later."
        case .unauthorized:
            return "Authentication error. Please sign in again."
        case .encodingError, .decodingError:
            return "Message format error. Please try again."
        case .notFound:
            return "Conversation not found. Please refresh and try again."
        case .unknown:
            return "Failed to send message. Please try again."
        }
    }
    return "Failed to send message: \(error.localizedDescription)"
}

/// Helper: Save failed message to local storage
private func saveFailedMessageLocally(_ message: Message) {
    failedMessageStore.save(message)
}
```

Update init to load failed messages:

```swift
init(...) {
    // ... existing init code ...
    
    // Load failed messages from local persistence
    loadFailedMessages()
    
    observeMessages()
}
```

---

#### 4. UI for Failed Message Alert

**File:** `MessageAI/Presentation/Views/Chat/ChatView.swift`

Add alert state:

```swift
struct ChatView: View {
    @ObservedObject var viewModel: ChatViewModel
    
    @State private var showFailedMessageAlert = false
    @State private var selectedFailedMessage: Message?
    
    var body: some View {
        // ... existing UI ...
        .alert("Message Failed", isPresented: $showFailedMessageAlert, presenting: selectedFailedMessage) { message in
            Button("Retry", role: .none) {
                Task {
                    await viewModel.retryMessage(message)
                }
            }
            Button("Delete", role: .destructive) {
                viewModel.deleteFailedMessage(message)
            }
            Button("Cancel", role: .cancel) {}
        } message: { message in
            Text("This message failed to send. Would you like to retry or delete it?")
        }
    }
}
```

---

#### 5. Failed Message Visual Indicator

**File:** `MessageAI/Presentation/Views/Chat/MessageKitWrapper.swift`

Update message cell configuration to show red warning icon for failed messages:

```swift
// In CustomMessagesViewController
func configureMessageCollectionView() {
    // ... existing code ...
    
    // Add tap gesture for failed messages
    let tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleMessageTap(_:)))
    messagesCollectionView.addGestureRecognizer(tapGesture)
}

@objc private func handleMessageTap(_ gesture: UITapGestureRecognizer) {
    let touchLocation = gesture.location(in: messagesCollectionView)
    
    guard let indexPath = messagesCollectionView.indexPathForItem(at: touchLocation) else {
        return
    }
    
    let message = messageForItem(at: indexPath, in: messagesCollectionView)
    
    // Check if message is failed and belongs to current user
    if let messageKitMsg = message as? MessageKitMessage,
       let originalMessage = viewModel.messages.first(where: { $0.id == messageKitMsg.messageId }),
       originalMessage.status == .failed,
       originalMessage.senderId == viewModel.currentUserId {
        
        // Trigger failed message alert in SwiftUI
        viewModel.onFailedMessageTapped(originalMessage)
    }
}
```

Add method to ChatViewModel:

```swift
@Published var failedMessageTapped: Message?

func onFailedMessageTapped(_ message: Message) {
    failedMessageTapped = message
}
```

Update ChatView to observe:

```swift
.onChange(of: viewModel.failedMessageTapped) { message in
    if let message = message {
        selectedFailedMessage = message
        showFailedMessageAlert = true
        viewModel.failedMessageTapped = nil  // Clear
    }
}
```

---

#### 6. MessageKit Status Indicator Display

Add accessory view to show status icon:

```swift
extension CustomMessagesViewController: MessagesDisplayDelegate {
    func messageBottomLabelAttributedText(for message: MessageType, at indexPath: IndexPath) -> NSAttributedString? {
        guard let messageKitMsg = message as? MessageKitMessage else {
            return nil
        }
        
        // Find original message
        guard let originalMessage = viewModel.messages.first(where: { $0.id == messageKitMsg.messageId }) else {
            return nil
        }
        
        // Show status for own messages
        if originalMessage.senderId == viewModel.currentUserId {
            let statusText: String
            let statusColor: UIColor
            
            switch originalMessage.status {
            case .sending:
                statusText = "Sending..."
                statusColor = .systemGray
            case .sent:
                statusText = "âœ“ Sent"
                statusColor = .systemGray
            case .delivered:
                statusText = "âœ“âœ“ Delivered"
                statusColor = .systemGray
            case .read:
                statusText = "âœ“âœ“ Read"
                statusColor = .systemBlue
            case .failed:
                statusText = "âš ï¸ Failed - Tap to retry"
                statusColor = .systemRed
            }
            
            let attributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.systemFont(ofSize: 10),
                .foregroundColor: statusColor
            ]
            
            return NSAttributedString(string: statusText, attributes: attributes)
        }
        
        return nil
    }
    
    func messageBottomLabelHeight(for message: MessageType, at indexPath: IndexPath, in messagesCollectionView: MessagesCollectionView) -> CGFloat {
        return 16
    }
}
```

---

### Architecture Context

#### Tech Stack
[Source: docs/architecture/tech-stack.md]

- **Language:** Swift 5.9+ with async/await
- **UI Framework:** SwiftUI + MessageKit 4.2.0
- **State Management:** Combine + @Published
- **Local Persistence:** UserDefaults (for failed messages)
- **Backend:** Firebase Firestore

#### Data Models
[Source: docs/architecture/data-models.md#message]

**MessageStatus Enum:**
- Already includes `.failed` status âœ…
- `sortOrder` allows failed messages to retry
- `canTransitionTo()` validates status transitions

**Message Entity:**
- `status: MessageStatus` - Tracks delivery state
- `statusUpdatedAt: Date` - When status last changed
- All fields already exist

#### File Locations
[Source: docs/architecture/ios-app-architecture.md]

**Files to Modify:**
- `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift` - Add retry/delete methods
- `MessageAI/Presentation/Views/Chat/ChatView.swift` - Add failed message alert
- `MessageAI/Presentation/Views/Chat/MessageKitWrapper.swift` - Add status indicators

**New Files to Create:**
- `MessageAI/Data/Persistence/FailedMessageStore.swift` - Local persistence
- `MessageAITests/Data/Persistence/FailedMessageStoreTests.swift` - Unit tests

**Test Files to Modify:**
- `MessageAITests/Presentation/ViewModels/ChatViewModelTests.swift` - Add retry tests

#### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Critical Rules for This Story:**

1. **Optimistic UI Updates** (Rule #5):
   - Keep failed message in array (don't remove)
   - Update status to .failed
   - Allow retry with optimistic .sending status

2. **Error Handling** (Rule #6):
   - Map RepositoryError to user-friendly messages
   - Network errors: "No internet connection"
   - Show actionable options (Retry/Delete)

3. **Local Persistence:**
   - Use UserDefaults for simplicity (MVP)
   - JSON encode/decode Message entities
   - Load on ViewModel init

4. **Array Reassignment:**
   - Always reassign array: `messages = updated`
   - Triggers @Published change detection

---

## Tasks / Subtasks

### Task 1: Create FailedMessageStore for Local Persistence (AC: 5, 9)
- [ ] 1.1: Create `FailedMessageStore.swift` in Data/Persistence/
- [ ] 1.2: Implement `save(_ message: Message)` using UserDefaults
- [ ] 1.3: Implement `loadAll() -> [Message]`
- [ ] 1.4: Implement `remove(_ messageId: String)`
- [ ] 1.5: Implement `clearAll()` for testing
- [ ] 1.6: Write unit test: `testSaveFailedMessage`
- [ ] 1.7: Write unit test: `testLoadFailedMessages`
- [ ] 1.8: Write unit test: `testRemoveFailedMessage`
- [ ] 1.9: Write unit test: `testPersistenceAcrossAppRestarts`

### Task 2: Update ChatViewModel Error Handling (AC: 1, 7, 10)
- [ ] 2.1: Add `failedMessageStore` property
- [ ] 2.2: Add `retryingMessageId` @Published property
- [ ] 2.3: Modify `sendMessage()` catch block to mark message as .failed
- [ ] 2.4: Call `saveFailedMessageLocally()` on send failure
- [ ] 2.5: Implement `mapErrorToUserMessage()` helper
- [ ] 2.6: Implement `loadFailedMessages()` method
- [ ] 2.7: Call `loadFailedMessages()` in init
- [ ] 2.8: Write unit test: `testSendMessageFailureMarksAsFailed`
- [ ] 2.9: Write unit test: `testFailedMessagePersistedLocally`
- [ ] 2.10: Write unit test: `testLoadFailedMessagesOnInit`

### Task 3: Implement Retry Logic (AC: 3, 8)
- [ ] 3.1: Implement `retryMessage(_ message: Message)` async method
- [ ] 3.2: Update message status to .sending during retry
- [ ] 3.3: Call `messageRepository.sendMessage()` 
- [ ] 3.4: On success: Update status to .sent, remove from store
- [ ] 3.5: On failure: Update status back to .failed
- [ ] 3.6: Add 3-second timeout for retry operation
- [ ] 3.7: Write unit test: `testRetryMessageSuccess`
- [ ] 3.8: Write unit test: `testRetryMessageFailure`
- [ ] 3.9: Write unit test: `testRetryPerformanceWithin3Seconds`

### Task 4: Implement Delete Failed Message (AC: 4)
- [ ] 4.1: Implement `deleteFailedMessage(_ message: Message)` method
- [ ] 4.2: Remove message from messages array
- [ ] 4.3: Remove message from failedMessageStore
- [ ] 4.4: Write unit test: `testDeleteFailedMessage`
- [ ] 4.5: Write unit test: `testDeleteRemovedFromPersistence`

### Task 5: Add Failed Message UI Alert (AC: 2)
- [ ] 5.1: Add `@Published var failedMessageTapped: Message?` to ChatViewModel
- [ ] 5.2: Implement `onFailedMessageTapped()` method
- [ ] 5.3: Add `showFailedMessageAlert` State to ChatView
- [ ] 5.4: Add `selectedFailedMessage` State to ChatView
- [ ] 5.5: Add `.alert()` modifier with Retry/Delete/Cancel buttons
- [ ] 5.6: Connect Retry button to `viewModel.retryMessage()`
- [ ] 5.7: Connect Delete button to `viewModel.deleteFailedMessage()`
- [ ] 5.8: Add `.onChange(of: viewModel.failedMessageTapped)` observer

### Task 6: Add Visual Failed Message Indicator (AC: 1)
- [ ] 6.1: Update MessageKitWrapper tap gesture to detect failed messages
- [ ] 6.2: Implement `handleMessageTap()` to check message status
- [ ] 6.3: Trigger alert for failed messages
- [ ] 6.4: Implement `messageBottomLabelAttributedText()` in MessagesDisplayDelegate
- [ ] 6.5: Show "âš ï¸ Failed - Tap to retry" for failed messages
- [ ] 6.6: Use red color for failed status indicator
- [ ] 6.7: Show other statuses: Sending, Sent, Delivered, Read

### Task 7: Manual Testing & Validation (AC: 8, 10, 12)
- [ ] 7.1: Test send failure with airplane mode
- [ ] 7.2: Verify failed message shows red warning icon
- [ ] 7.3: Tap failed message, verify alert appears
- [ ] 7.4: Test Retry button (turn off airplane mode first)
- [ ] 7.5: Test Delete button
- [ ] 7.6: Test failed message persists after app restart
- [ ] 7.7: Test retry performance (< 3 seconds)
- [ ] 7.8: Test network error types (timeout, no connection, Firebase error)
- [ ] 7.9: Verify error messages user-friendly

### Task 8: Regression Testing (AC: 13)
- [ ] 8.1: Run story-level tests: `./scripts/test-story.sh ChatViewModelTests`
- [ ] 8.2: Run epic-level tests: `./scripts/test-epic.sh 2`
- [ ] 8.3: Verify normal message sending still works (Story 1.8)
- [ ] 8.4: Verify message editing still works (Story 2.2)
- [ ] 8.5: Verify message deletion still works (Story 2.3)

---

## Testing

### Testing Strategy
[Source: docs/architecture/testing-strategy.md]

**Tier 1: Story-Level Tests (5-20 seconds)**
```bash
./scripts/test-story.sh ChatViewModelTests
./scripts/test-story.sh FailedMessageStoreTests
```

**Tier 2: Epic-Level Tests (20-40 seconds)**
```bash
./scripts/test-epic.sh 2
```

**Run during development after each task completion.**

---

### Unit Tests Required

#### FailedMessageStoreTests.swift (NEW)

1. **testSaveFailedMessage**
   - Create message with .failed status
   - Save to store
   - Verify UserDefaults contains message

2. **testLoadFailedMessages**
   - Save 3 failed messages
   - Load all messages
   - Verify count = 3 and messages match

3. **testRemoveFailedMessage**
   - Save 2 failed messages
   - Remove one by ID
   - Verify count = 1, correct message removed

4. **testUpdateExistingFailedMessage**
   - Save message with .failed status
   - Save same message ID again (update)
   - Verify only 1 message in store

5. **testPersistenceAcrossAppRestarts**
   - Save failed message
   - Create new FailedMessageStore instance
   - Load messages
   - Verify message still exists

6. **testClearAll**
   - Save 5 failed messages
   - Call clearAll()
   - Verify loadAll() returns empty array

#### ChatViewModelTests.swift

7. **testSendMessageFailureMarksAsFailed**
   - Mock repository to throw network error
   - Call sendMessage()
   - Verify message status = .failed
   - Verify message still in messages array

8. **testFailedMessagePersistedLocally**
   - Mock repository to throw error
   - Send message (fails)
   - Verify FailedMessageStore contains message

9. **testLoadFailedMessagesOnInit**
   - Save 2 failed messages to store
   - Create new ChatViewModel
   - Verify messages loaded into messages array

10. **testRetryMessageSuccess**
    - Create failed message in messages array
    - Mock repository to succeed
    - Call retryMessage()
    - Verify status = .sent
    - Verify removed from FailedMessageStore

11. **testRetryMessageFailure**
    - Create failed message
    - Mock repository to throw error
    - Call retryMessage()
    - Verify status still = .failed
    - Verify still in FailedMessageStore

12. **testRetryPerformanceWithin3Seconds**
    - Mock repository with 2-second delay
    - Call retryMessage()
    - Measure time
    - Verify completes within 3 seconds

13. **testDeleteFailedMessage**
    - Create failed message in array
    - Call deleteFailedMessage()
    - Verify removed from messages array
    - Verify removed from FailedMessageStore

14. **testMapErrorToUserMessage**
    - Test RepositoryError.networkError â†’ "No internet connection"
    - Test RepositoryError.unauthorized â†’ "Authentication error"
    - Test RepositoryError.encodingError â†’ "Message format error"
    - Verify all errors mapped to user-friendly strings

15. **testMultipleFailedMessagesInArray**
    - Send 3 messages, all fail
    - Verify all 3 in messages array with .failed status
    - Verify all 3 in FailedMessageStore

---

### Manual Testing Checklist

#### Test 1: Send Failure with Airplane Mode
1. Sign in as test1@messageai.dev
2. Open conversation with test2
3. Turn on airplane mode
4. Type message: "This will fail"
5. Tap Send
6. **Expected:** Message appears in chat with red "âš ï¸ Failed - Tap to retry" indicator
7. **Expected:** Message status = failed
8. **Expected:** Message stays in chat (not removed)

#### Test 2: Failed Message Alert
1. Continue from Test 1
2. Tap the failed message
3. **Expected:** Alert appears: "Message failed to send. [Retry] [Delete] [Cancel]"
4. Tap Cancel
5. **Expected:** Alert dismisses, message still visible

#### Test 3: Retry Failed Message - Success
1. Continue from Test 2
2. Turn off airplane mode (restore connection)
3. Tap failed message again
4. Tap "Retry" button
5. **Expected:** Message status changes to "Sending..."
6. **Expected:** Within 3 seconds, status changes to "âœ“ Sent"
7. **Expected:** Red warning icon disappears
8. Device B: Verify message received

#### Test 4: Retry Failed Message - Failure
1. Turn on airplane mode
2. Send message (fails)
3. Tap failed message, tap Retry
4. **Expected:** Retry fails (still offline)
5. **Expected:** Status returns to "âš ï¸ Failed"
6. **Expected:** Error message: "No internet connection"

#### Test 5: Delete Failed Message
1. Offline: Send message (fails)
2. Tap failed message
3. Tap "Delete" button
4. **Expected:** Message removed from chat immediately
5. **Expected:** No longer in conversation

#### Test 6: Failed Message Persistence (App Restart)
1. Offline: Send 3 messages (all fail)
2. **Expected:** All 3 show failed indicators
3. Force quit app (swipe up in app switcher)
4. Relaunch app
5. Open same conversation
6. **Expected:** All 3 failed messages still visible
7. **Expected:** All have failed status indicator

#### Test 7: Multiple Failed Messages
1. Offline: Send 5 messages
2. **Expected:** All 5 show as failed
3. Go online
4. Retry all 5 individually
5. **Expected:** All 5 succeed (one at a time)

#### Test 8: Network Error Types

**8a. No Connection:**
1. Airplane mode ON
2. Send message
3. **Expected:** "No internet connection. Message will be saved..."

**8b. Firebase Error (simulate):**
1. Temporarily break Firebase config
2. Send message
3. **Expected:** User-friendly error, not raw error string
4. **Expected:** Message marked as failed, can retry

#### Test 9: Retry Performance
1. Go offline
2. Send message
3. Go online
4. Start timer, tap Retry
5. **Expected:** Status changes to Sent within 3 seconds

#### Test 10: Regression - Normal Sending Works
1. Ensure online
2. Send 10 messages normally
3. **Expected:** All send successfully
4. **Expected:** All show "âœ“ Sent" status
5. **Expected:** No failed messages

---

### Edge Cases to Test

1. **Retry while offline:** Should fail again gracefully
2. **Delete failed message, then retry:** Should handle gracefully (message gone)
3. **Multiple rapid retries:** Should ignore taps while retrying
4. **Restart app with 50 failed messages:** Should load all without lag
5. **Failed message deleted on other device:** Handle sync gracefully

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-10-21 | 1.0 | Story created - Message Send Retry on Failure | Bob (SM) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

---

## QA Results

*This section will be populated by QA agent after implementation.*

