# Story 2.0: Start New Conversation with Duplicate Prevention

## Status

**Done**

---

## Story

**As a** user,  
**I want** to start a new conversation by selecting a contact,  
**so that** I can message anyone in the system without creating duplicate conversations.

---

## Acceptance Criteria

1. "New Message" button (+ icon) displayed in navigation bar of conversations list
2. Tap "New Message" opens user selection view showing all available users (excluding current user)
3. User selection view displays: avatar, display name, and email for each user
4. Search/filter functionality to find users by name or email
5. Tap user initiates `getOrCreateConversation()` repository method
6. **Duplicate Prevention Logic:**
   - Query Firestore for existing conversation with exact participant match
   - Sort participant IDs for consistent comparison (alphabetical order)
   - If conversation exists, navigate to existing conversation (no duplicate created)
   - If no conversation exists, create new conversation and navigate to it
7. **Repository Method:** `ConversationRepositoryProtocol.getOrCreateConversation(participantIds: [String]) async throws -> Conversation`
8. Loading indicator shown during conversation lookup/creation
9. Error handling: Network failures show retry option
10. **Race Condition Handling:** If two users simultaneously try to create same conversation, Firestore query detects existing conversation created by other user
11. New conversation appears immediately in conversations list for both participants
12. Performance: Conversation lookup/creation completes within 2 seconds
13. Reliability: Works offline - queued for creation when connection restored
14. **Unit Tests:**
    - Test `getOrCreateConversation` returns existing conversation when found
    - Test `getOrCreateConversation` creates new conversation when not found
    - Test participant ID sorting (ensure [A,B] matches [B,A])
    - Test duplicate detection with 2+ users
15. **Integration Test:** User A creates conversation with User B, User B tries to create conversation with User A, verify same conversation returned
16. **Edge Cases:**
    - Self-conversation prevention (can't create conversation with self)
    - Conversation with deleted/non-existent user ID shows error
    - Multiple rapid taps on "New Message" don't create duplicates

**MVP Scope Note:** This story implements `getAllUsers()` which returns all users in the system. This approach is suitable for MVP and small-scale deployments (< 100 users) but does not scale for large multi-tenant applications. Story 3.0 (Organization/Workspace System) will address this limitation by implementing organization-based user scoping, replacing `getAllUsers()` with `getUsersInOrganization(organizationId)`.

---

## Previous Story Context (Story 1.10 Completion)

### Key Learnings from Story 1.10

**Test Infrastructure Established:**
- 94 unit tests passing across all ViewModels and entities
- Firebase Emulator configured and working with integration tests
- Performance baselines established (< 2s message send)
- Mock repositories comprehensive (MockAuthRepository, MockUserRepository, MockConversationRepository, MockMessageRepository)

**Testing Patterns:**
- ViewModels marked with `@MainActor` require test classes also marked `@MainActor`
- Use `Task.sleep` delays (10-100ms) after async init to allow Combine publishers to settle
- Integration tests use `throw XCTSkip()` when emulator not running (graceful degradation)
- Quick test script (`./scripts/quick-test.sh --quick`) is 10x faster than Xcode UI testing

**Architecture Patterns:**
- Repository protocol extensions enable adding new methods without breaking existing code
- DIContainer uses lazy var initialization for repositories
- ViewModels injected via factory methods in DIContainer
- NetworkMonitor protocol-based design enables testability

**Impact on Story 2.0:**
- Existing mock repositories need new methods added (`getOrCreateConversation`, `getAllUsers`)
- New ViewModel (NewConversationViewModel) should follow established patterns (TestFlight deployment not relevant)
- Integration tests should follow skeleton-first approach (implement later with emulator)
- Performance testing shows Firestore queries complete <500ms typically

---

## Dev Notes

### Architecture Context

#### 1. Layer Structure

This story spans three Clean Architecture layers:

**Domain Layer:** [Source: docs/architecture/ios-app-architecture.md#layer-structure]
- Add `getOrCreateConversation()` to `ConversationRepositoryProtocol`
- Add `getAllUsers()` to `UserRepositoryProtocol`
- No new entities (reuses existing `Conversation` and `User`)

**Data Layer:**
- Implement `getOrCreateConversation()` in `FirebaseConversationRepository`
- Implement `getAllUsers()` in `FirebaseUserRepository`

**Presentation Layer:**
- Create `NewConversationViewModel` in `Presentation/ViewModels/Conversations/`
- Create `NewConversationView` in `Presentation/Views/Conversations/`
- Update `ConversationsListView` to add "New Message" button

#### 2. Data Models

**Conversation Entity:** [Source: docs/architecture/data-models.md#conversation]

```swift
struct Conversation: Codable, Equatable, Identifiable {
    let id: String
    var participantIds: [String]           // Array of user IDs (MAX 10)
    var lastMessage: String?
    var lastMessageTimestamp: Date?
    var lastMessageSenderId: String?
    var lastMessageId: String?
    var unreadCounts: [String: Int]        // userId -> unread count
    var typingUsers: [String]
    let createdAt: Date
    var isGroup: Bool                      // True if 3+ participants
    var groupName: String?
    var aiSummary: String?
    var actionItemCount: Int
    var decisionCount: Int
    var lastAISummaryAt: Date?
    let schemaVersion: Int = 1
}
```

**Key Points:**
- `participantIds` must be sorted alphabetically for duplicate detection
- `isGroup` is `false` for 2-person conversations (this story)
- `createdAt` timestamp used to determine oldest conversation when cleaning duplicates
- `unreadCounts` initialized to `[userId: 0]` for both participants

**User Entity:** [Source: docs/architecture/data-models.md#user]

```swift
struct User: Codable, Equatable, Identifiable {
    let id: String
    let email: String
    var displayName: String
    var photoURL: String?
    var isOnline: Bool
    var lastSeen: Date
    let createdAt: Date
}
```

#### 3. Repository Protocols

**Add to ConversationRepositoryProtocol:**

```swift
/// Get existing conversation or create new one with duplicate prevention
/// - Parameter participantIds: Array of user IDs (will be sorted internally)
/// - Returns: Existing conversation if found, otherwise newly created conversation
func getOrCreateConversation(participantIds: [String]) async throws -> Conversation
```

**Add to UserRepositoryProtocol:**

```swift
/// Get all users in the system (for user selection view)
/// - Returns: Array of all User entities
func getAllUsers() async throws -> [User]
```

#### 4. Repository Implementation Logic

**FirebaseConversationRepository.getOrCreateConversation():**

```swift
func getOrCreateConversation(participantIds: [String]) async throws -> Conversation {
    print("üîç Looking for existing conversation with participants: \(participantIds)")
    
    // 1. Sort participant IDs for consistent comparison
    let sortedIds = participantIds.sorted()
    
    // 2. Query Firestore for conversations containing first participant
    let snapshot = try await db.collection("conversations")
        .whereField("participantIds", arrayContains: sortedIds[0])
        .getDocuments()
    
    // 3. Check each conversation for exact match
    for document in snapshot.documents {
        guard let conversation = try? Firestore.Decoder.default.decode(
            Conversation.self, 
            from: document.data()
        ) else {
            continue
        }
        
        let existingIds = conversation.participantIds.sorted()
        
        // Exact match found
        if existingIds == sortedIds {
            print("‚úÖ Found existing conversation: \(conversation.id)")
            return conversation
        }
    }
    
    // 4. No match found - create new conversation
    print("üÜï Creating new conversation")
    return try await createConversation(participantIds: sortedIds)
}
```

**Key Implementation Details:**
- Use `arrayContains` query (requires array contains first sorted ID)
- Firestore queries are case-sensitive, so ID sorting is critical
- Race conditions handled by query (if conversation created between query and create, query will find it on retry)
- Offline behavior: Firestore queues both query and write operations

#### 5. ViewModel Pattern

**NewConversationViewModel:** [Source: docs/architecture/ios-app-architecture.md#viewmodel-pattern]

```swift
@MainActor
class NewConversationViewModel: ObservableObject {
    // MARK: - Published State
    @Published var users: [User] = []
    @Published var filteredUsers: [User] = []
    @Published var searchText: String = ""
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var selectedConversation: Conversation?  // For navigation
    
    // MARK: - Dependencies
    private let userRepository: UserRepositoryProtocol
    private let conversationRepository: ConversationRepositoryProtocol
    private let authRepository: AuthRepositoryProtocol  // For current user ID
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Initialization
    init(
        userRepository: UserRepositoryProtocol,
        conversationRepository: ConversationRepositoryProtocol,
        authRepository: AuthRepositoryProtocol
    ) {
        self.userRepository = userRepository
        self.conversationRepository = conversationRepository
        self.authRepository = authRepository
        
        setupSearchObserver()
    }
    
    // MARK: - Public Methods
    
    func loadUsers() async {
        isLoading = true
        errorMessage = nil
        
        do {
            let allUsers = try await userRepository.getAllUsers()
            
            // Filter out current user
            guard let currentUserId = authRepository.currentUser?.id else {
                throw RepositoryError.unauthorized
            }
            
            users = allUsers.filter { $0.id != currentUserId }
            filteredUsers = users
            
            print("‚úÖ Loaded \(users.count) users")
        } catch {
            errorMessage = "Failed to load users: \(error.localizedDescription)"
            print("‚ùå Failed to load users: \(error)")
        }
        
        isLoading = false
    }
    
    func selectUser(_ user: User) async {
        isLoading = true
        errorMessage = nil
        
        do {
            guard let currentUserId = authRepository.currentUser?.id else {
                throw RepositoryError.unauthorized
            }
            
            // Prevent self-conversation
            guard user.id != currentUserId else {
                errorMessage = "You cannot start a conversation with yourself."
                isLoading = false
                return
            }
            
            let participantIds = [currentUserId, user.id]
            let conversation = try await conversationRepository.getOrCreateConversation(
                participantIds: participantIds
            )
            
            selectedConversation = conversation  // Triggers navigation
            print("‚úÖ Conversation ready: \(conversation.id)")
            
        } catch {
            errorMessage = "Failed to create conversation: \(error.localizedDescription)"
            print("‚ùå Failed to create conversation: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Private Methods
    
    private func setupSearchObserver() {
        $searchText
            .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .sink { [weak self] searchText in
                self?.filterUsers(searchText)
            }
            .store(in: &cancellables)
    }
    
    private func filterUsers(_ searchText: String) {
        if searchText.isEmpty {
            filteredUsers = users
        } else {
            filteredUsers = users.filter { user in
                user.displayName.localizedCaseInsensitiveContains(searchText) ||
                user.email.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
}
```

#### 6. SwiftUI View Pattern

**NewConversationView:**

```swift
struct NewConversationView: View {
    @StateObject var viewModel: NewConversationViewModel
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack {
                // Search bar
                SearchBar(text: $viewModel.searchText)
                    .padding()
                
                // User list
                if viewModel.isLoading {
                    ProgressView("Loading users...")
                } else if let error = viewModel.errorMessage {
                    ErrorView(message: error) {
                        Task {
                            await viewModel.loadUsers()
                        }
                    }
                } else {
                    List(viewModel.filteredUsers) { user in
                        UserRowView(user: user)
                            .onTapGesture {
                                Task {
                                    await viewModel.selectUser(user)
                                }
                            }
                    }
                }
            }
            .navigationTitle("New Message")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .task {
                await viewModel.loadUsers()
            }
            .onChange(of: viewModel.selectedConversation) { conversation in
                if conversation != nil {
                    dismiss()  // Return to conversations list, navigation handled there
                }
            }
        }
    }
}
```

**UserRowView Component:**

```swift
struct UserRowView: View {
    let user: User
    
    var body: some View {
        HStack(spacing: 12) {
            // Avatar (photo or initials)
            if let photoURL = user.photoURL, let url = URL(string: photoURL) {
                AsyncImage(url: url) { image in
                    image.resizable()
                        .scaledToFill()
                } placeholder: {
                    ProgressView()
                }
                .frame(width: 50, height: 50)
                .clipShape(Circle())
            } else {
                Circle()
                    .fill(Color.blue)
                    .frame(width: 50, height: 50)
                    .overlay(
                        Text(user.displayName.prefix(2).uppercased())
                            .foregroundColor(.white)
                            .font(.headline)
                    )
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text(user.displayName)
                    .font(.headline)
                
                Text(user.email)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // Online indicator
            if user.isOnline {
                Circle()
                    .fill(Color.green)
                    .frame(width: 12, height: 12)
            }
        }
        .padding(.vertical, 4)
    }
}
```

#### 7. Update ConversationsListView

Add "New Message" button to navigation bar:

```swift
.toolbar {
    ToolbarItem(placement: .navigationBarTrailing) {
        Button {
            showNewConversation = true
        } label: {
            Image(systemName: "square.and.pencil")
        }
        .accessibilityLabel("New Message")
    }
    
    // Existing logout button...
}
.sheet(isPresented: $showNewConversation) {
    NewConversationView(
        viewModel: DIContainer.shared.makeNewConversationViewModel()
    )
}
```

#### 8. DIContainer Updates

Add factory method: [Source: docs/architecture/ios-app-architecture.md#dependency-injection]

```swift
func makeNewConversationViewModel() -> NewConversationViewModel {
    NewConversationViewModel(
        userRepository: userRepository,
        conversationRepository: conversationRepository,
        authRepository: authRepository
    )
}
```

#### 9. Firestore Query Performance

[Source: docs/architecture/data-models.md#firestore-indexing]

**Required Composite Index:**
- Collection: `conversations`
- Fields: `participantIds` (ARRAY) + `createdAt` (DESC)

This index enables fast duplicate detection queries. Create via Firebase Console or let Firestore auto-create on first query.

#### 10. Offline Behavior

[Source: docs/architecture/data-models.md#offline-persistence]

**Query Offline:**
- Firestore returns cached conversations for duplicate detection
- If no cached results, proceeds to create new conversation

**Create Offline:**
- New conversation queued in Firestore pending queue
- Both participants see conversation locally (optimistic UI)
- Syncs when connection restored

#### 11. Testing Strategy

[Source: docs/architecture/testing-best-practices.md#unit-testing-viewmodels]

**Unit Tests (10-12 tests):**

**NewConversationViewModelTests:**
1. `testLoadUsers_Success` - Verify users loaded and current user excluded
2. `testLoadUsers_Failure` - Verify error message set
3. `testSearchFilter_ByName` - Verify search filters by display name
4. `testSearchFilter_ByEmail` - Verify search filters by email
5. `testSearchFilter_Empty` - Verify all users shown when search empty
6. `testSelectUser_Success` - Verify selectedConversation set
7. `testSelectUser_SelfConversation` - Verify error shown for self-conversation
8. `testSelectUser_Failure` - Verify error message set
9. `testSearchDebounce` - Verify search debounced (300ms)

**FirebaseConversationRepositoryTests:**
10. `testGetOrCreateConversation_ExistingFound` - Returns existing conversation
11. `testGetOrCreateConversation_CreatesNew` - Creates new when none exists
12. `testGetOrCreateConversation_ParticipantSorting` - [A,B] matches [B,A]

**FirebaseUserRepositoryTests:**
13. `testGetAllUsers_Success` - Returns all users from Firestore

**Integration Tests (1 skeleton):**
- `testGetOrCreateConversation_RaceCondition` - User A and B create simultaneously, same conversation returned

#### 12. Accessibility

[Source: docs/architecture/coding-standards.md#accessibility]

All interactive elements need `.accessibilityLabel()`:
- "New Message" button
- User rows: "[Display Name], [Email], [Online/Offline]"
- Search field: "Search users"
- Cancel button: "Cancel"

Test with VoiceOver: Cmd+Shift+V in simulator

#### 13. Error Handling

**Network Errors:**
- Display user-friendly message
- Show "Retry" button
- Log technical details to console

**Edge Cases:**
- Current user nil ‚Üí show "Authentication required"
- Empty users list ‚Üí show "No users found"
- Self-conversation attempt ‚Üí show "Cannot message yourself"

---

## Tasks / Subtasks

### Phase 1: Repository Protocol Updates

#### Task 1: Update ConversationRepositoryProtocol (AC: 7)
1. Add `getOrCreateConversation(participantIds:)` method to protocol
2. Document parameters and return value
3. Add source references in comments

#### Task 2: Update UserRepositoryProtocol (AC: 2)
1. Add `getAllUsers()` method to protocol
2. Document return value

### Phase 2: Repository Implementations

#### Task 3: Implement FirebaseConversationRepository.getOrCreateConversation() (AC: 6, 10)
1. Sort participant IDs alphabetically
2. Query Firestore using `arrayContains` with first sorted ID
3. Iterate through results checking for exact match
4. Return existing conversation if found
5. Call `createConversation()` if not found
6. Add logging (üîç searching, ‚úÖ found, üÜï creating)
7. Handle Firestore errors with proper error translation

#### Task 4: Implement FirebaseUserRepository.getAllUsers() (AC: 2)
1. Query `users` collection in Firestore
2. Decode documents to `[User]` array
3. Sort by `displayName` alphabetically
4. Handle errors with RepositoryError translation
5. Add logging

### Phase 3: Update Mock Repositories (Testing Support)

#### Task 5: Update MockConversationRepository
1. Add `getOrCreateConversation` method
2. Add `getOrCreateConversationCalled` tracking boolean
3. Add `capturedParticipantIds` array for verification
4. Add `mockConversation` property for return value
5. Add `shouldFail` boolean for error testing
6. Update `reset()` method

#### Task 6: Update MockUserRepository
1. Add `getAllUsers` method
2. Add `getAllUsersCalled` tracking boolean
3. Add `mockUsers` array property
4. Add `shouldFail` boolean
5. Update `reset()` method

### Phase 4: ViewModel Implementation

#### Task 7: Create NewConversationViewModel (AC: 2, 3, 4, 5, 8, 9)
1. Create file at `Presentation/ViewModels/Conversations/NewConversationViewModel.swift`
2. Mark with `@MainActor` for SwiftUI compatibility
3. Add @Published properties: users, filteredUsers, searchText, isLoading, errorMessage, selectedConversation
4. Inject repositories via initializer
5. Implement `loadUsers()` async method
   - Call `userRepository.getAllUsers()`
   - Filter out current user
   - Set users and filteredUsers
   - Handle errors
6. Implement `selectUser(_ user:)` async method
   - Validate not self-conversation
   - Call `getOrCreateConversation()`
   - Set selectedConversation for navigation
   - Handle errors
7. Implement `setupSearchObserver()` private method
   - Debounce searchText by 300ms
   - Call filterUsers()
8. Implement `filterUsers(_ searchText:)` private method
   - Filter by displayName and email (case-insensitive)
9. Add logging statements

### Phase 5: UI Implementation

#### Task 8: Create UserRowView Component (AC: 3)
1. Create file at `Presentation/Components/UserRowView.swift`
2. Display avatar (photo or initials circle)
3. Display display name (headline font)
4. Display email (subheadline, secondary color)
5. Display online indicator (green circle if online)
6. Add proper spacing and padding
7. Add accessibility labels

#### Task 9: Create NewConversationView (AC: 2, 4, 8)
1. Create file at `Presentation/Views/Conversations/NewConversationView.swift`
2. Add NavigationView wrapper
3. Add SearchBar at top
4. Add user list with UserRowView rows
5. Handle tap on user row (call viewModel.selectUser)
6. Add loading state (ProgressView)
7. Add error state (ErrorView with retry)
8. Add .task modifier to call loadUsers on appear
9. Add .onChange for selectedConversation (dismiss sheet)
10. Add navigation bar with "Cancel" button
11. Add accessibility labels

#### Task 10: Update ConversationsListView (AC: 1, 11)
1. Add `@State private var showNewConversation = false`
2. Add toolbar button (square.and.pencil icon)
3. Add .sheet modifier for NewConversationView
4. Add accessibility label to button
5. Ensure conversation list updates when returning (already handled by real-time listener)

### Phase 6: Dependency Injection

#### Task 11: Update DIContainer (AC: 5)
1. Add `makeNewConversationViewModel()` factory method
2. Inject userRepository, conversationRepository, authRepository

### Phase 7: Unit Testing

#### Task 12: Create NewConversationViewModelTests (AC: 14)
1. Create test file with @MainActor annotation
2. Implement 9 unit tests (see Dev Notes #11)
3. Use MockUserRepository and MockConversationRepository
4. Test loading, searching, selecting, error handling
5. Run `./scripts/quick-test.sh --quick` to verify

#### Task 13: Update FirebaseConversationRepositoryTests (AC: 14)
1. Add 3 unit tests for getOrCreateConversation
2. Test existing conversation found
3. Test new conversation created
4. Test participant ID sorting logic
5. Use XCTSkip if emulator not running

#### Task 14: Update FirebaseUserRepositoryTests (AC: 14)
1. Add test for getAllUsers
2. Verify all users returned
3. Use XCTSkip if emulator not running

### Phase 8: Integration Testing

#### Task 15: Create Integration Test Skeleton (AC: 15)
1. Add test to `RealTimeMessagingIntegrationTests.swift`
2. Test: User A creates conversation, User B creates same conversation
3. Verify same conversation ID returned
4. Use `throw XCTSkip("Requires Firebase Emulator")` for now
5. Add Given/When/Then comments for future implementation

### Phase 9: Manual Testing & Verification

#### Task 16: Manual Testing Checklist
1. Launch app and sign in
2. Verify "New Message" button visible in conversations list nav bar
3. Tap button ‚Üí verify user selection sheet opens
4. Verify current user NOT in list
5. Verify all other users displayed with avatar, name, email
6. Test search functionality (name and email)
7. Tap user ‚Üí verify loading indicator shown
8. Verify navigation to chat view
9. Back to conversations list ‚Üí verify conversation appears
10. Tap "New Message" again ‚Üí select same user
11. **VERIFY: Same conversation opened (no duplicate created)**
12. Test offline: Enable airplane mode, try to create conversation
13. Verify queued for creation (loading state or offline indicator)
14. Disable airplane mode ‚Üí verify conversation created
15. Test error: Force network error ‚Üí verify error message and retry button
16. Test accessibility: Enable VoiceOver, verify all labels
17. Test dark mode: Switch to dark mode, verify UI renders correctly

#### Task 17: Run Full Test Suite
```bash
./scripts/quick-test.sh
```
Verify all tests pass (94 existing + 13 new = 107 total)

### Phase 10: Code Review & Documentation

#### Task 18: Self Code Review
1. Verify all acceptance criteria met
2. Check error handling comprehensive
3. Verify accessibility labels added
4. Confirm logging statements added
5. Verify no force-unwraps or ! operators
6. Check consistent naming conventions

#### Task 19: Update Dev Agent Record (Below)

---

## Dev Agent Record

### Implementation Notes

*(To be populated by Dev Agent during implementation)*

**Completion Summary:**
- [ ] All 19 tasks completed
- [ ] All acceptance criteria met
- [ ] 13 unit tests added (107 total)
- [ ] Manual testing checklist complete
- [ ] No regressions introduced

**Technical Decisions:**

**Challenges Encountered:**

**Deviations from Story:**

**Performance Notes:**

**File List:**

**New Files Created:**
- `MessageAI/Domain/Repositories/ConversationRepositoryProtocol.swift` (updated)
- `MessageAI/Domain/Repositories/UserRepositoryProtocol.swift` (updated)
- `MessageAI/Data/Repositories/FirebaseConversationRepository.swift` (updated)
- `MessageAI/Data/Repositories/FirebaseUserRepository.swift` (updated)
- `MessageAI/Presentation/ViewModels/Conversations/NewConversationViewModel.swift`
- `MessageAI/Presentation/Views/Conversations/NewConversationView.swift`
- `MessageAI/Presentation/Components/UserRowView.swift`
- `MessageAITests/Presentation/ViewModels/NewConversationViewModelTests.swift`

**Modified Files:**
- `MessageAI/Presentation/Views/Conversations/ConversationsListView.swift`
- `MessageAI/App/DIContainer.swift`
- `MessageAITests/Data/Mocks/MockConversationRepository.swift`
- `MessageAITests/Data/Mocks/MockUserRepository.swift`
- `MessageAITests/Data/Repositories/FirebaseConversationRepositoryTests.swift`
- `MessageAITests/Data/Repositories/FirebaseUserRepositoryTests.swift`
- `MessageAITests/Integration/RealTimeMessagingIntegrationTests.swift`

---

## QA Results

*(This section will be populated by the QA Agent after implementation)*

---


