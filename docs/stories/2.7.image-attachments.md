# Story 2.7: Image Attachments

## Status

**Approved**

---

## Story

**As a** user,
**I want** to attach and send images in my conversations,
**so that** I can share visual content with others.

---

## Acceptance Criteria

1. Photo library picker accessible via attachment button in message input bar
2. Image compression applied before upload (target: < 2MB per image)
3. Upload progress indicator shows percentage during Firebase Storage upload
4. Image appears optimistically in chat while uploading (with loading indicator)
5. MessageKit displays image message in chat bubble (tappable for full-screen view)
6. Full-screen image viewer with pinch-to-zoom and share functionality
7. Failed uploads show retry option with clear error message
8. Firebase Storage security rules enforce 2MB limit and conversation participant access
9. Messages support single image attachment (multi-image deferred to post-MVP)
10. Offline queue: Images queued locally, uploaded when connection restored
11. Storage path structure: `images/{conversationId}/{messageId}/image.jpg`
12. Image thumbnails cached locally (Kingfisher) for fast re-display
13. Unit tests for image upload, compression, and error handling
14. Integration test: Upload image, verify appears for other participants within 2 seconds
15. Performance: Image upload completes within 5 seconds on WiFi for 2MB image
16. Regression test: Text messages, editing, read receipts still work with image messages

---

## Previous Story Context (Story 2.6 Completion)

### Key Learnings from Story 2.6

**Real-Time State Management:**
- Firestore listener patterns for automatic UI updates
- Throttling to reduce Firestore writes (max 1/second for typing indicators)
- Lifecycle management (onAppear/onDisappear) for cleanup
- Cloud Functions for automatic cleanup of stale state

**Performance Optimization:**
- Write throttling reduced Firestore costs by 70-80%
- Efficient use of Firestore arrayUnion/arrayRemove for atomic updates
- Real-time listeners with < 500ms latency

**ChatViewModel Patterns:**
- Timer management for auto-stop behavior
- Published properties for SwiftUI binding
- Error handling with user-friendly messages
- Repository protocol extensions for new functionality

### Impact on Story 2.7

Story 2.7 builds on these patterns:
- **Optimistic UI**: Show image immediately in chat (similar to message send)
- **Progress tracking**: Use @Published properties for upload progress
- **Error handling**: Retry mechanism similar to message send retry (Story 2.4)
- **Lifecycle management**: Cancel uploads when leaving chat
- **Repository pattern**: Extend StorageRepositoryProtocol for image uploads

---

## What's Already Done (Infrastructure from Previous Stories)

### ✅ Message Entity with Attachment Support (Epic 1, Story 1.3)

The `Message` entity already includes the `attachments` field:

**File:** `MessageAI/Domain/Entities/Message.swift`

```swift
struct Message: Codable, Equatable, Identifiable {
    let id: String
    let conversationId: String
    let senderId: String
    var text: String
    let timestamp: Date
    var status: MessageStatus
    var attachments: [MessageAttachment]  // ✅ ALREADY EXISTS
    // ... other fields
}
```

### ✅ MessageAttachment Entity (Epic 1, Story 1.3)

**File:** `MessageAI/Domain/Entities/MessageAttachment.swift`

```swift
struct MessageAttachment: Codable, Equatable {
    let id: String
    let type: AttachmentType
    let url: String              // Firebase Storage download URL
    let thumbnailURL: String?    // Optional thumbnail URL
    let sizeBytes: Int64         // File size for display

    enum AttachmentType: String, Codable {
        case image               // ✅ Story 2.7
        case video              // Future
        case file               // Future (Story 2.8 - PDF)
    }
}
```

### ✅ StorageRepositoryProtocol (Epic 1, Story 1.6)

**File:** `MessageAI/Domain/Repositories/StorageRepositoryProtocol.swift`

```swift
protocol StorageRepositoryProtocol {
    func uploadProfileImage(_ image: UIImage, userId: String) async throws -> String
    func deleteFile(at path: String) async throws

    // Story 2.7 will ADD these methods:
    // func uploadMessageImage(_ image: UIImage, conversationId: String, messageId: String) async throws -> MessageAttachment
    // func observeUploadProgress(for messageId: String) -> AnyPublisher<Double, Never>
}
```

### ✅ FirebaseStorageRepository Implementation (Epic 1, Story 1.6)

**File:** `MessageAI/Data/Repositories/FirebaseStorageRepository.swift`

Profile image upload already implemented with:
- Image compression (0.7 quality JPEG)
- Error handling with user-friendly StorageError enum
- Firebase Storage SDK integration
- Metadata setting (content-type)

Story 2.7 will extend this repository with message image methods.

### ✅ Firebase Storage Security Rules (Epic 1, Story 1.6)

**File:** `storage.rules`

```javascript
// Image attachments: /images/{conversationId}/{messageId}/{filename}
match /images/{conversationId}/{messageId}/{filename} {
  // Allow upload if authenticated and participant (with 2MB limit)
  allow write: if isAuthenticated()
    && isParticipant(conversationId)
    && request.resource.size < 2 * 1024 * 1024;  // ✅ 2MB limit enforced

  // Allow read if authenticated and participant
  allow read: if isAuthenticated() && isParticipant(conversationId);
}
```

**Status:** ✅ Already deployed and tested

### ✅ MessageKit Integration (Epic 1, Story 1.8)

MessageKit already supports image messages via `MessageType.photo(MediaItem)`:

```swift
// MessageKit automatically handles:
// - Image bubble display
// - Tap to open full-screen
// - Loading indicators
// - Error states
```

### ✅ Kingfisher (Epic 1, Story 1.1)

**Tech Stack:** Kingfisher 7.10.0 already added to project

```swift
// Handles:
// - Async image loading
// - Memory and disk caching
// - Placeholder images
// - Error handling
```

---

## What's NEW in Story 2.7

Story 2.7 adds the **iOS client-side implementation** for image attachments:

### 1. StorageRepositoryProtocol Extension

**NEW METHODS:**
```swift
/// Upload message image with progress tracking
func uploadMessageImage(
    _ image: UIImage,
    conversationId: String,
    messageId: String,
    progressHandler: ((Double) -> Void)?
) async throws -> MessageAttachment

/// Cancel an in-progress upload
func cancelUpload(for messageId: String) async throws
```

### 2. FirebaseStorageRepository Implementation

**NEW:**
- Image compression (target: < 2MB, quality: 0.7-0.9 JPEG)
- Upload progress tracking with Combine publishers
- Storage path: `images/{conversationId}/{messageId}/image.jpg`
- Cancellation support
- Error mapping for user-friendly messages

### 3. ChatViewModel Image Upload Logic

**NEW:**
- `@Published var uploadProgress: [String: Double]` - Track progress per message
- `@Published var uploadErrors: [String: String]` - Track errors per message
- `selectImage()` - Open photo library picker
- `sendImageMessage(image: UIImage)` - Compress, upload, send
- `retryImageUpload(messageId: String)` - Retry failed upload
- `cancelImageUpload(messageId: String)` - Cancel in-progress upload

### 4. ImagePickerView SwiftUI Component

**NEW FILE:** UIViewControllerRepresentable wrapper for UIImagePickerController

### 5. FullScreenImageView SwiftUI Component

**NEW FILE:** Full-screen image viewer with pinch-to-zoom, share, dismiss

### 6. ChatView Integration

**UPDATE:**
- Add attachment button (camera icon) next to message input
- Display ImagePickerView sheet when tapped
- Show upload progress overlay on image messages
- Handle image message taps for full-screen view

### 7. MessageKit DataSource Updates

**UPDATE:** `ChatViewModel` MessageKit integration to support photo messages

### 8. Unit Tests

**NEW FILE:** Test image compression, upload, retry, cancellation

---

## Tasks / Subtasks

### Task 0: Understand Existing Infrastructure (AC: Foundation)
- [ ] Review `Message.attachments` field and `MessageAttachment` entity
- [ ] Review existing `StorageRepositoryProtocol` and `FirebaseStorageRepository`
- [ ] Review Firebase Storage security rules in `storage.rules`
- [ ] Review MessageKit photo message support documentation
- [ ] Review Story 1.6 (Profile Setup) for image upload patterns

### Task 1: Extend StorageRepositoryProtocol (AC: 3, 7, 10)
- [ ] Add `uploadMessageImage(_:conversationId:messageId:progressHandler:) async throws -> MessageAttachment`
- [ ] Add `cancelUpload(for:) async throws` method signature
- [ ] Document method behavior (compression, progress, cancellation)
- [ ] Add methods to MockStorageRepository with tracking booleans

### Task 2: Implement Image Compression Utility (AC: 2)
- [ ] Create `MessageAI/Presentation/Utils/ImageCompressor.swift`
- [ ] Implement `compress(image: UIImage, maxSizeBytes: Int64) -> UIImage?`
- [ ] Target: < 2MB (2 * 1024 * 1024 bytes)
- [ ] Start with 0.8 quality, reduce to 0.7/0.6 if still too large
- [ ] Resize if dimensions exceed 1920x1920 (maintain aspect ratio)
- [ ] Return nil if compression fails

### Task 3: Implement uploadMessageImage in FirebaseStorageRepository (AC: 3, 8, 11, 15)
- [ ] Compress image using ImageCompressor utility
- [ ] Create storage path: `images/{conversationId}/{messageId}/image.jpg`
- [ ] Create StorageReference and metadata (contentType: image/jpeg)
- [ ] Use `putDataAsync()` with progress observer
- [ ] Call progressHandler closure with upload percentage (0.0-1.0)
- [ ] Get download URL after upload completes
- [ ] Create MessageAttachment with URL, size, type: .image
- [ ] Handle errors with StorageError translation
- [ ] Log upload duration and final size

### Task 4: Implement Upload Cancellation (AC: 7)
- [ ] Store active upload tasks in dictionary: `[String: StorageUploadTask]`
- [ ] Implement `cancelUpload(for messageId:)` method
- [ ] Look up task in dictionary, call `.cancel()`, remove from dictionary
- [ ] Handle cancellation errors gracefully

### Task 5: Add Image Upload Logic to ChatViewModel (AC: 1, 4, 7, 10)
- [ ] Add `@Published var uploadProgress: [String: Double] = [:]`
- [ ] Add `@Published var uploadErrors: [String: String] = [:]`
- [ ] Add `@Published var isImagePickerPresented: Bool = false`
- [ ] Implement `selectImage()` method (sets isImagePickerPresented = true)
- [ ] Implement `sendImageMessage(image: UIImage)` method:
  - Generate message ID
  - Create Message with empty text, status: .sending, attachments: []
  - Append to messages array (optimistic UI)
  - Upload image in background Task
  - Update uploadProgress[messageId] during upload
  - On success: Update message with attachment, set status: .sent
  - On failure: Set uploadErrors[messageId], show retry UI
- [ ] Implement `retryImageUpload(messageId: String)` method
- [ ] Implement `cancelImageUpload(messageId: String)` method
- [ ] Handle network reconnection (observe NetworkMonitor, retry queued uploads)

### Task 6: Create ImagePickerView Component (AC: 1)
- [ ] Create `MessageAI/Presentation/Components/ImagePickerView.swift`
- [ ] UIViewControllerRepresentable wrapping UIImagePickerController
- [ ] Source type: .photoLibrary
- [ ] Media type: public.image
- [ ] Coordinator pattern for delegate methods
- [ ] Return selected UIImage via binding
- [ ] Handle cancellation

### Task 7: Create FullScreenImageView Component (AC: 6)
- [ ] Create `MessageAI/Presentation/Components/FullScreenImageView.swift`
- [ ] Display image with Kingfisher (supports pinch-to-zoom)
- [ ] Add close button (X icon in top-right)
- [ ] Add share button (UIActivityViewController)
- [ ] Add double-tap to zoom
- [ ] Black background, overlay controls

### Task 8: Integrate ImagePickerView into ChatView (AC: 1)
- [ ] Add attachment button (paperclip or camera icon) next to message input
- [ ] Bind button tap to viewModel.selectImage()
- [ ] Display ImagePickerView sheet when isImagePickerPresented = true
- [ ] Pass selected image to viewModel.sendImageMessage(image:)
- [ ] Add loading indicator during compression/upload

### Task 9: Display Upload Progress on Image Messages (AC: 3, 4)
- [ ] Create custom MessageKit cell for image messages with progress
- [ ] Overlay CircularProgressView when uploadProgress[messageId] exists
- [ ] Show percentage text (e.g., "45%")
- [ ] Hide progress overlay when uploadProgress[messageId] == 1.0
- [ ] Show error overlay with retry button when uploadErrors[messageId] exists

### Task 10: Handle Image Message Taps (Full-Screen View) (AC: 6)
- [ ] Add tap gesture recognizer to image messages in MessageKit
- [ ] Present FullScreenImageView when image message tapped
- [ ] Pass image URL to FullScreenImageView
- [ ] Use fullScreenCover modifier for presentation

### Task 11: Update MessageKit DataSource for Photo Messages (AC: 5)
- [ ] Update ChatViewModel to conform to MessagesDataSource
- [ ] Implement `messageKind(for message:)` to return `.photo` for image attachments
- [ ] Create MediaItem struct conforming to MessageKit.MediaItem protocol
- [ ] Set image URL, placeholder, size in MediaItem
- [ ] Use Kingfisher for async image loading in MessageKit cells

### Task 12: Offline Queue Management (AC: 10)
- [ ] Store failed uploads in UserDefaults: `[messageId: imageData]`
- [ ] Observe NetworkMonitor.isConnected
- [ ] On reconnection: Iterate queued uploads, call retryImageUpload()
- [ ] Remove from queue on successful upload
- [ ] Show "Queued" status for offline image messages

### Task 13: Unit Tests for ImageCompressor (AC: 13)
- [ ] Create `MessageAITests/Presentation/Utils/ImageCompressorTests.swift`
- [ ] `testCompressImage_Under2MB()` - Verify output < 2MB
- [ ] `testCompressImage_LargeImage()` - 10MB input → < 2MB output
- [ ] `testCompressImage_MaintainsAspectRatio()` - Verify dimensions
- [ ] `testCompressImage_NilForInvalidImage()` - Handles edge cases

### Task 14: Unit Tests for ChatViewModel Image Upload (AC: 13)
- [ ] Add tests in `ChatViewModelTests.swift`
- [ ] `testSendImageMessage_Success()` - Verify message appended, upload called
- [ ] `testSendImageMessage_Progress()` - Verify uploadProgress updated
- [ ] `testSendImageMessage_Failure()` - Verify uploadErrors set, retry available
- [ ] `testRetryImageUpload()` - Verify retry calls uploadMessageImage again
- [ ] `testCancelImageUpload()` - Verify cancel called on repository
- [ ] `testOfflineImageQueue()` - Verify image queued when offline, uploaded when online

### Task 15: Unit Tests for StorageRepository (AC: 13)
- [ ] Add tests in `FirebaseStorageRepositoryTests.swift`
- [ ] `testUploadMessageImage_Success()` - Verify upload returns MessageAttachment
- [ ] `testUploadMessageImage_ProgressUpdates()` - Verify progress handler called
- [ ] `testUploadMessageImage_Cancellation()` - Verify upload cancelled
- [ ] `testUploadMessageImage_CompressionApplied()` - Verify image < 2MB
- [ ] `testUploadMessageImage_HandlesError()` - Verify StorageError thrown

### Task 16: Manual Testing Checklist (AC: 14, 15, 16)
- [ ] Test two simulators (User A and User B)
- [ ] User A taps attachment button → Photo picker opens
- [ ] User A selects image → Image compresses, uploads, appears in chat
- [ ] User B sees image message appear within 2 seconds
- [ ] User A taps image → Full-screen view opens with zoom
- [ ] Test share button → iOS share sheet appears
- [ ] Test large image (10MB) → Compresses to < 2MB, uploads in < 5 seconds (WiFi)
- [ ] Test offline upload → Image queued, uploads when reconnected
- [ ] Test cancel upload mid-progress → Upload cancelled, message removed or retryable
- [ ] Test failed upload → Retry button appears, retry succeeds
- [ ] Performance: Send 5 text messages, 2 images → All work correctly (regression)

### Task 17: Integration Test (AC: 14)
- [ ] Create integration test: `testImageUpload_RealTimeSync()`
- [ ] User A uploads image (mock UIImage, upload to Firebase Storage)
- [ ] User B observes messages (real-time listener)
- [ ] Verify User B sees image message with attachment URL within 2 seconds
- [ ] Verify attachment.type == .image
- [ ] Verify attachment.sizeBytes > 0

---

## Dev Notes

### Previous Story Context

**From Story 2.6 (Typing Indicators):**

Story 2.6 demonstrated effective patterns for:
- Real-time state tracking with Firestore listeners
- Progress indication (typing indicator animations)
- Throttling to reduce cloud costs (1/second limit)
- Lifecycle management (cleanup on view disappear)
- Error handling with user-friendly messages

Story 2.7 applies similar patterns:
- **Progress tracking**: Use @Published var uploadProgress similar to typing state
- **Optimistic UI**: Show image immediately (like message sending)
- **Lifecycle cleanup**: Cancel uploads when leaving chat
- **Error handling**: Retry mechanism with clear user feedback

**From Story 2.4 (Message Retry):**

Story 2.4 established retry patterns for failed operations:
- Failed message UI (red warning icon)
- Retry/Delete alert
- Persistent failure queue
- Network error handling

Story 2.7 extends these patterns to image uploads.

**From Story 1.6 (Profile Setup):**

Story 1.6 implemented image upload infrastructure:
- Image compression (JPEG 0.7 quality)
- Firebase Storage upload with StorageRepository
- Error handling with StorageError enum
- Download URL retrieval

Story 2.7 builds on this foundation for message images.

### Architecture Context

**Tech Stack:** [Source: docs/architecture/tech-stack.md]

- **Swift**: 5.9+, async/await for async operations
- **SwiftUI**: iOS 15+, declarative UI with @Published bindings
- **MessageKit**: 4.2.0, supports photo messages via `.photo(MediaItem)`
- **Kingfisher**: 7.10.0, async image loading and caching
- **Firebase Storage**: File upload with security rules, progress tracking

**Data Models:** [Source: docs/architecture/data-models.md#message]

```swift
struct Message: Codable, Equatable, Identifiable {
    let id: String
    let conversationId: String
    var text: String               // Empty for image-only messages
    var attachments: [MessageAttachment]  // New: Contains uploaded image
    var status: MessageStatus      // .sending → .sent (or .failed)
    // ... other fields
}

struct MessageAttachment: Codable, Equatable {
    let id: String
    let type: AttachmentType       // .image for Story 2.7
    let url: String                // Firebase Storage download URL
    let thumbnailURL: String?      // Optional (not used in Story 2.7)
    let sizeBytes: Int64           // Compressed image size
}
```

**Database Schema:** [Source: docs/architecture/database-schema.md]

```
messages/
  └── {messageId}/
      ├── attachments: array[
            {
              id: string,
              type: "image",
              url: "https://firebasestorage.googleapis.com/...",
              thumbnailURL: null,
              sizeBytes: 1245678
            }
          ]
```

**Firebase Storage Paths:**

```
images/
  └── {conversationId}/
      └── {messageId}/
          └── image.jpg           # Compressed JPEG (< 2MB)
```

**Storage Security Rules:** [Source: storage.rules]

```javascript
// Already deployed ✅
match /images/{conversationId}/{messageId}/{filename} {
  // Enforce 2MB limit at server level
  allow write: if isAuthenticated()
    && isParticipant(conversationId)
    && request.resource.size < 2 * 1024 * 1024;

  // Only conversation participants can read
  allow read: if isAuthenticated() && isParticipant(conversationId);
}
```

### Repository Protocol Extension

**File:** `MessageAI/Domain/Repositories/StorageRepositoryProtocol.swift`

Add these methods:

```swift
/// Upload message image with optional progress tracking
/// - Parameters:
///   - image: UIImage to compress and upload
///   - conversationId: Parent conversation ID (for storage path and security)
///   - messageId: Message ID (for storage path and progress tracking)
///   - progressHandler: Optional closure called with upload progress (0.0-1.0)
/// - Returns: MessageAttachment with download URL and metadata
func uploadMessageImage(
    _ image: UIImage,
    conversationId: String,
    messageId: String,
    progressHandler: ((Double) -> Void)?
) async throws -> MessageAttachment

/// Cancel an in-progress upload
/// - Parameter messageId: The message ID of the upload to cancel
func cancelUpload(for messageId: String) async throws
```

### FirebaseStorageRepository Implementation

**File:** `MessageAI/Data/Repositories/FirebaseStorageRepository.swift`

```swift
// Track active uploads for cancellation
private var activeUploads: [String: StorageUploadTask] = [:]

func uploadMessageImage(
    _ image: UIImage,
    conversationId: String,
    messageId: String,
    progressHandler: ((Double) -> Void)?
) async throws -> MessageAttachment {
    print("📤 [StorageRepo] Uploading image for message: \(messageId)")

    // Step 1: Compress image
    guard let compressedImage = ImageCompressor.compress(
        image: image,
        maxSizeBytes: 2 * 1024 * 1024  // 2MB
    ) else {
        throw StorageError.imageProcessingFailed
    }

    guard let imageData = compressedImage.jpegData(compressionQuality: 0.8) else {
        throw StorageError.imageProcessingFailed
    }

    let sizeBytes = Int64(imageData.count)
    print("✅ [StorageRepo] Image compressed: \(sizeBytes) bytes")

    // Step 2: Create storage reference
    let storagePath = "images/\(conversationId)/\(messageId)/image.jpg"
    let storageRef = storage.reference().child(storagePath)

    // Step 3: Set metadata
    let metadata = StorageMetadata()
    metadata.contentType = "image/jpeg"

    do {
        // Step 4: Upload with progress tracking
        let uploadTask = storageRef.putData(imageData, metadata: metadata)
        activeUploads[messageId] = uploadTask

        // Observe progress
        uploadTask.observe(.progress) { snapshot in
            guard let progress = snapshot.progress else { return }
            let percentComplete = Double(progress.completedUnitCount)
                                / Double(progress.totalUnitCount)

            Task { @MainActor in
                progressHandler?(percentComplete)
            }
        }

        // Wait for completion
        let uploadMetadata = try await uploadTask
        activeUploads.removeValue(forKey: messageId)

        print("✅ [StorageRepo] Upload complete: \(storagePath)")

        // Step 5: Get download URL
        let downloadURL = try await storageRef.downloadURL()

        // Step 6: Create MessageAttachment
        let attachment = MessageAttachment(
            id: UUID().uuidString,
            type: .image,
            url: downloadURL.absoluteString,
            thumbnailURL: nil,  // Not needed for Story 2.7
            sizeBytes: sizeBytes
        )

        return attachment

    } catch let error as NSError {
        activeUploads.removeValue(forKey: messageId)
        print("❌ [StorageRepo] Upload failed: \(error.localizedDescription)")

        // Map Firebase Storage errors
        if error.domain == "FIRStorageErrorDomain" {
            switch error.code {
            case -13021: throw StorageError.unauthorized
            case -13020: throw StorageError.permissionDenied
            case -13030: throw StorageError.quotaExceeded
            case -13040: throw StorageError.uploadCancelled
            default: throw StorageError.uploadFailed(error.localizedDescription)
            }
        }

        throw StorageError.uploadFailed(error.localizedDescription)
    }
}

func cancelUpload(for messageId: String) async throws {
    guard let uploadTask = activeUploads[messageId] else {
        print("⚠️ [StorageRepo] No active upload found for message: \(messageId)")
        return
    }

    uploadTask.cancel()
    activeUploads.removeValue(forKey: messageId)
    print("✅ [StorageRepo] Upload cancelled for message: \(messageId)")
}
```

### ImageCompressor Utility

**File:** `MessageAI/Presentation/Utils/ImageCompressor.swift`

```swift
import UIKit

/// Utility for compressing images before upload
enum ImageCompressor {
    /// Compress image to target size
    /// - Parameters:
    ///   - image: Source UIImage
    ///   - maxSizeBytes: Maximum size in bytes (default: 2MB)
    /// - Returns: Compressed UIImage, or nil if compression fails
    static func compress(image: UIImage, maxSizeBytes: Int64 = 2 * 1024 * 1024) -> UIImage? {
        // Step 1: Resize if dimensions are too large
        let resizedImage = resize(image: image, maxDimension: 1920)

        // Step 2: Compress with decreasing quality until under maxSizeBytes
        var compression: CGFloat = 0.8
        var imageData = resizedImage.jpegData(compressionQuality: compression)

        while let data = imageData, data.count > maxSizeBytes && compression > 0.1 {
            compression -= 0.1
            imageData = resizedImage.jpegData(compressionQuality: compression)
        }

        guard let finalData = imageData, finalData.count <= maxSizeBytes else {
            print("❌ ImageCompressor: Failed to compress image under \(maxSizeBytes) bytes")
            return nil
        }

        print("✅ ImageCompressor: Compressed to \(finalData.count) bytes (quality: \(compression))")
        return UIImage(data: finalData)
    }

    /// Resize image if larger than maxDimension (maintains aspect ratio)
    private static func resize(image: UIImage, maxDimension: CGFloat) -> UIImage {
        let size = image.size
        guard max(size.width, size.height) > maxDimension else {
            return image  // Already small enough
        }

        let scale = maxDimension / max(size.width, size.height)
        let newSize = CGSize(width: size.width * scale, height: size.height * scale)

        let renderer = UIGraphicsImageRenderer(size: newSize)
        let resizedImage = renderer.image { _ in
            image.draw(in: CGRect(origin: .zero, size: newSize))
        }

        print("✅ ImageCompressor: Resized from \(size) to \(newSize)")
        return resizedImage
    }
}
```

### ChatViewModel Image Upload Logic

**File:** `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift`

Add these properties:

```swift
// MARK: - Image Upload Properties

@Published var uploadProgress: [String: Double] = [:]      // messageId → progress (0.0-1.0)
@Published var uploadErrors: [String: String] = [:]        // messageId → error message
@Published var isImagePickerPresented: Bool = false
@Published var selectedImage: UIImage?
```

Add these methods:

```swift
// MARK: - Image Upload Methods

/// Open image picker
func selectImage() {
    isImagePickerPresented = true
}

/// Send image message with compression and upload
func sendImageMessage(image: UIImage) {
    Task {
        let messageId = UUID().uuidString

        // Step 1: Create optimistic message
        let message = Message(
            id: messageId,
            conversationId: conversationId,
            senderId: currentUserId,
            text: "",  // Image-only message
            timestamp: Date(),
            status: .sending,
            attachments: []  // Will be populated after upload
        )

        messages.append(message)
        uploadProgress[messageId] = 0.0

        // Step 2: Upload image in background
        do {
            let attachment = try await storageRepository.uploadMessageImage(
                image,
                conversationId: conversationId,
                messageId: messageId
            ) { progress in
                Task { @MainActor in
                    self.uploadProgress[messageId] = progress
                }
            }

            // Step 3: Update message with attachment
            var updatedMessage = message
            updatedMessage.attachments = [attachment]
            updatedMessage.status = .sent
            updatedMessage.statusUpdatedAt = Date()

            // Save to Firestore
            try await messageRepository.sendMessage(updatedMessage)

            // Update local array
            if let index = messages.firstIndex(where: { $0.id == messageId }) {
                messages[index] = updatedMessage
            }

            uploadProgress.removeValue(forKey: messageId)
            print("✅ Image message sent: \(messageId)")

        } catch {
            print("❌ Image upload failed: \(error.localizedDescription)")

            // Update message status to failed
            if let index = messages.firstIndex(where: { $0.id == messageId }) {
                messages[index].status = .failed
            }

            uploadProgress.removeValue(forKey: messageId)
            uploadErrors[messageId] = "Failed to upload image. Tap to retry."
        }
    }
}

/// Retry failed image upload
func retryImageUpload(messageId: String) {
    guard let message = messages.first(where: { $0.id == messageId }),
          let image = selectedImage else {  // Need to re-fetch image
        print("⚠️ Cannot retry: Image not available")
        errorMessage = "Please select the image again to retry."
        return
    }

    uploadErrors.removeValue(forKey: messageId)
    sendImageMessage(image: image)
}

/// Cancel in-progress upload
func cancelImageUpload(messageId: String) {
    Task {
        do {
            try await storageRepository.cancelUpload(for: messageId)

            // Remove message from list
            messages.removeAll { $0.id == messageId }
            uploadProgress.removeValue(forKey: messageId)
            uploadErrors.removeValue(forKey: messageId)

            print("✅ Upload cancelled: \(messageId)")
        } catch {
            print("❌ Failed to cancel upload: \(error.localizedDescription)")
        }
    }
}
```

Update `onDisappear()` to cancel uploads:

```swift
func onDisappear() {
    stopTyping()  // From Story 2.6

    // Cancel all active uploads
    for messageId in uploadProgress.keys {
        Task {
            try? await storageRepository.cancelUpload(for: messageId)
        }
    }
}
```

### ImagePickerView Component

**File:** `MessageAI/Presentation/Components/ImagePickerView.swift`

```swift
import SwiftUI
import UIKit

/// SwiftUI wrapper for UIImagePickerController
struct ImagePickerView: UIViewControllerRepresentable {
    @Binding var selectedImage: UIImage?
    @Environment(\.dismiss) var dismiss

    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .photoLibrary
        picker.mediaTypes = ["public.image"]
        return picker
    }

    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {
        // No updates needed
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePickerView

        init(_ parent: ImagePickerView) {
            self.parent = parent
        }

        func imagePickerController(
            _ picker: UIImagePickerController,
            didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]
        ) {
            if let image = info[.originalImage] as? UIImage {
                parent.selectedImage = image
            }
            parent.dismiss()
        }

        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.dismiss()
        }
    }
}
```

### FullScreenImageView Component

**File:** `MessageAI/Presentation/Components/FullScreenImageView.swift`

```swift
import SwiftUI
import Kingfisher

/// Full-screen image viewer with pinch-to-zoom
struct FullScreenImageView: View {
    let imageURL: String
    @Environment(\.dismiss) var dismiss
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 1.0

    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()

            // Image with zoom
            KFImage(URL(string: imageURL))
                .resizable()
                .scaledToFit()
                .scaleEffect(scale)
                .gesture(
                    MagnificationGesture()
                        .onChanged { value in
                            scale = lastScale * value
                        }
                        .onEnded { _ in
                            lastScale = scale
                            // Reset if zoomed out too far
                            if scale < 1.0 {
                                withAnimation {
                                    scale = 1.0
                                    lastScale = 1.0
                                }
                            }
                        }
                )
                .onTapGesture(count: 2) {
                    // Double-tap to reset zoom
                    withAnimation {
                        scale = 1.0
                        lastScale = 1.0
                    }
                }

            // Overlay controls
            VStack {
                HStack {
                    Spacer()

                    // Close button
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.white)
                            .padding()
                            .background(Color.black.opacity(0.5))
                            .clipShape(Circle())
                    }
                    .padding()
                }

                Spacer()

                // Share button
                Button {
                    shareImage(url: imageURL)
                } label: {
                    HStack {
                        Image(systemName: "square.and.arrow.up")
                        Text("Share")
                    }
                    .foregroundColor(.white)
                    .padding()
                    .background(Color.black.opacity(0.5))
                    .cornerRadius(12)
                }
                .padding()
            }
        }
    }

    private func shareImage(url: String) {
        guard let url = URL(string: url) else { return }

        // Download image first
        KingfisherManager.shared.retrieveImage(with: url) { result in
            switch result {
            case .success(let imageResult):
                let activityVC = UIActivityViewController(
                    activityItems: [imageResult.image],
                    applicationActivities: nil
                )

                // Present on current window
                if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                   let rootVC = windowScene.windows.first?.rootViewController {
                    rootVC.present(activityVC, animated: true)
                }

            case .failure(let error):
                print("❌ Failed to load image for sharing: \(error)")
            }
        }
    }
}
```

### ChatView Integration

**File:** `MessageAI/Presentation/Views/Chat/ChatView.swift`

Add attachment button and image picker:

```swift
var body: some View {
    VStack(spacing: 0) {
        // Existing MessageKit wrapper
        MessageKitWrapper(viewModel: viewModel)

        // Typing indicator (from Story 2.6)
        TypingIndicatorView(typingUserNames: viewModel.typingUserNames)

        // Message input bar with attachment button
        HStack(spacing: 8) {
            // NEW: Attachment button
            Button {
                viewModel.selectImage()
            } label: {
                Image(systemName: "paperclip")
                    .font(.title2)
                    .foregroundColor(.blue)
            }
            .padding(.leading, 8)

            // Existing message input field
            TextField("Message", text: $viewModel.messageText)
                .textFieldStyle(RoundedBorderTextFieldStyle())

            // Existing send button
            Button {
                viewModel.sendMessage()
            } label: {
                Image(systemName: "arrow.up.circle.fill")
                    .font(.title2)
                    .foregroundColor(viewModel.messageText.isEmpty ? .gray : .blue)
            }
            .disabled(viewModel.messageText.isEmpty)
            .padding(.trailing, 8)
        }
        .padding(.vertical, 8)
    }
    .sheet(isPresented: $viewModel.isImagePickerPresented) {
        ImagePickerView(selectedImage: $viewModel.selectedImage)
    }
    .onChange(of: viewModel.selectedImage) { oldValue, newValue in
        if let image = newValue {
            viewModel.sendImageMessage(image: image)
            viewModel.selectedImage = nil  // Clear after sending
        }
    }
    .fullScreenCover(item: $selectedImageURL) { imageURL in
        FullScreenImageView(imageURL: imageURL)
    }
}
```

### MessageKit Photo Message Integration

**File:** `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift`

Update MessagesDataSource methods:

```swift
// MARK: - MessagesDataSource

func messageKind(for message: MessageType, at indexPath: IndexPath,
                 in messagesCollectionView: MessagesCollectionView) -> MessageKind {
    guard let message = message as? Message else {
        return .text("")
    }

    // Check for image attachment
    if let attachment = message.attachments.first, attachment.type == .image {
        let mediaItem = ImageMediaItem(url: attachment.url)
        return .photo(mediaItem)
    }

    // Default: text message
    return .text(message.text)
}

// MediaItem implementation for MessageKit
struct ImageMediaItem: MediaItem {
    var url: URL?
    var image: UIImage?
    var placeholderImage: UIImage
    var size: CGSize

    init(url: String) {
        self.url = URL(string: url)
        self.placeholderImage = UIImage(systemName: "photo") ?? UIImage()
        self.size = CGSize(width: 240, height: 240)  // Max display size
    }
}
```

Add Kingfisher integration for MessageKit:

```swift
// In MessagesDisplayDelegate
func configureMediaMessageImageView(
    _ imageView: UIImageView,
    for message: MessageType,
    at indexPath: IndexPath,
    in messagesCollectionView: MessagesCollectionView
) {
    guard let message = message as? Message,
          let attachment = message.attachments.first,
          let url = URL(string: attachment.url) else {
        return
    }

    // Use Kingfisher for async image loading
    imageView.kf.setImage(
        with: url,
        placeholder: UIImage(systemName: "photo"),
        options: [
            .transition(.fade(0.2)),
            .cacheOriginalImage
        ]
    )

    // Show upload progress overlay if uploading
    if let progress = uploadProgress[message.id] {
        addProgressOverlay(to: imageView, progress: progress)
    }
}

private func addProgressOverlay(to imageView: UIImageView, progress: Double) {
    // Remove existing overlay
    imageView.subviews.forEach { $0.removeFromSuperview() }

    // Create progress view
    let overlayView = UIView(frame: imageView.bounds)
    overlayView.backgroundColor = UIColor.black.withAlphaComponent(0.5)

    let progressView = UIProgressView(progressViewStyle: .default)
    progressView.progress = Float(progress)
    progressView.translatesAutoresizingMaskIntoConstraints = false

    overlayView.addSubview(progressView)
    imageView.addSubview(overlayView)

    NSLayoutConstraint.activate([
        progressView.centerXAnchor.constraint(equalTo: overlayView.centerXAnchor),
        progressView.centerYAnchor.constraint(equalTo: overlayView.centerYAnchor),
        progressView.widthAnchor.constraint(equalTo: overlayView.widthAnchor, multiplier: 0.6)
    ])
}
```

### Offline Queue Management

**File:** `MessageAI/Presentation/ViewModels/Chat/ChatViewModel.swift`

Add offline queue logic:

```swift
// MARK: - Offline Queue

private let offlineQueueKey = "offlineImageUploads"

/// Save failed upload to offline queue
private func queueOfflineUpload(messageId: String, imageData: Data) {
    var queue = UserDefaults.standard.dictionary(forKey: offlineQueueKey) ?? [:]
    queue[messageId] = imageData.base64EncodedString()
    UserDefaults.standard.set(queue, forKey: offlineQueueKey)
    print("📦 Queued offline upload: \(messageId)")
}

/// Retry all queued uploads when online
private func retryOfflineUploads() {
    guard let queue = UserDefaults.standard.dictionary(forKey: offlineQueueKey) as? [String: String],
          !queue.isEmpty else {
        return
    }

    print("📤 Retrying \(queue.count) offline uploads")

    for (messageId, base64Data) in queue {
        guard let imageData = Data(base64Encoded: base64Data),
              let image = UIImage(data: imageData) else {
            continue
        }

        // Retry upload
        sendImageMessage(image: image)

        // Remove from queue on success
        var updatedQueue = queue
        updatedQueue.removeValue(forKey: messageId)
        UserDefaults.standard.set(updatedQueue, forKey: offlineQueueKey)
    }
}

/// Observe network status and retry uploads
private func observeNetworkStatus() {
    NetworkMonitor.shared.$isConnected
        .sink { [weak self] isConnected in
            if isConnected {
                self?.retryOfflineUploads()
            }
        }
        .store(in: &cancellables)
}
```

Call `observeNetworkStatus()` in `init()`.

### Mock Repository Updates

**File:** `MessageAITests/Data/Mocks/MockStorageRepository.swift`

```swift
class MockStorageRepository: StorageRepositoryProtocol {
    // Tracking properties
    var uploadMessageImageCalled = false
    var capturedImage: UIImage?
    var capturedConversationId: String?
    var capturedMessageId: String?
    var capturedProgressHandler: ((Double) -> Void)?

    var cancelUploadCalled = false
    var capturedCancelMessageId: String?

    // Mock responses
    var mockAttachment: MessageAttachment?
    var shouldFail = false
    var mockError: Error?

    func uploadMessageImage(
        _ image: UIImage,
        conversationId: String,
        messageId: String,
        progressHandler: ((Double) -> Void)?
    ) async throws -> MessageAttachment {
        uploadMessageImageCalled = true
        capturedImage = image
        capturedConversationId = conversationId
        capturedMessageId = messageId
        capturedProgressHandler = progressHandler

        // Simulate progress
        progressHandler?(0.3)
        try await Task.sleep(nanoseconds: 100_000_000)  // 0.1s
        progressHandler?(0.6)
        try await Task.sleep(nanoseconds: 100_000_000)
        progressHandler?(1.0)

        if shouldFail {
            throw mockError ?? StorageError.uploadFailed("Mock error")
        }

        return mockAttachment ?? MessageAttachment(
            id: UUID().uuidString,
            type: .image,
            url: "https://mock.firebasestorage.com/image.jpg",
            thumbnailURL: nil,
            sizeBytes: 1024000
        )
    }

    func cancelUpload(for messageId: String) async throws {
        cancelUploadCalled = true
        capturedCancelMessageId = messageId

        if shouldFail {
            throw mockError ?? StorageError.uploadCancelled
        }
    }

    func reset() {
        uploadMessageImageCalled = false
        capturedImage = nil
        capturedConversationId = nil
        capturedMessageId = nil
        capturedProgressHandler = nil
        cancelUploadCalled = false
        capturedCancelMessageId = nil
        mockAttachment = nil
        shouldFail = false
        mockError = nil
    }
}
```

### Performance Considerations

**Image Compression Strategy:**

Story 2.7 uses aggressive compression to stay under 2MB:
- Start with 0.8 JPEG quality
- Reduce quality in 0.1 increments if over 2MB
- Resize images > 1920x1920 pixels (maintains aspect ratio)
- Fail upload if compression can't reach < 2MB

**Firestore Writes Estimate:**

- Image message: 1 write (message document with attachment URL)
- Same as text message (no extra writes)

**Firebase Storage Costs:**

- 2MB image upload: ~$0.000036 (Google Cloud Storage pricing)
- 50 images/day: ~$0.0018/day = $0.65/year
- Read bandwidth (CDN): $0.01/GB (Kingfisher caches, reduces reads)

**Upload Performance:**

- 2MB image on WiFi: 2-5 seconds (depends on connection)
- Progress updates: Every 5% (20 updates per upload)
- Cancellation: Immediate (within 100ms)

### Edge Cases

1. **User closes app mid-upload:** Upload continues in background (Firebase SDK handles). On next app open, check message status and retry if failed.
2. **Network loss mid-upload:** Upload fails, queued to offline queue, retries when online.
3. **Very large image (> 10MB):** Compression may fail to reach < 2MB. Show error: "Image too large. Please select a smaller image."
4. **Invalid image format:** `jpegData()` returns nil. Show error: "Unable to process image."
5. **Storage quota exceeded:** Firebase throws error. Show error: "Storage quota exceeded. Contact support."
6. **Concurrent uploads:** Dictionary tracks progress per messageId. Multiple uploads work independently.

### Testing Strategy

[Source: docs/architecture/testing-strategy.md]

**Unit Tests:**

```bash
# During development (5-20 seconds)
./scripts/test-story.sh ImageCompressorTests
./scripts/test-story.sh ChatViewModelImageUploadTests
```

**Epic Tests:**

```bash
# Before marking story complete (20-40 seconds)
./scripts/test-epic.sh 2
```

**Full Suite:**

```bash
# Before committing (1-2 minutes)
./scripts/quick-test.sh
```

**Test File Locations:**

```
MessageAITests/
├── Presentation/
│   ├── Utils/
│   │   └── ImageCompressorTests.swift          ← NEW
│   └── ViewModels/
│       └── ChatViewModelImageUploadTests.swift ← NEW (or extend existing ChatViewModelTests)
└── Data/
    └── Repositories/
        └── FirebaseStorageRepositoryTests.swift ← UPDATE (add image upload tests)
```

**Key Test Scenarios:**

1. **Compression:** 10MB image → < 2MB after compression
2. **Upload success:** Mock upload, verify MessageAttachment returned
3. **Upload progress:** Verify progressHandler called with 0.0, 0.5, 1.0
4. **Upload failure:** Mock error, verify uploadErrors set, retry available
5. **Cancellation:** Call cancelUpload(), verify upload task cancelled
6. **Offline queue:** Upload fails offline, retries when online
7. **Optimistic UI:** Message appears immediately with loading indicator

### Manual Testing Workflow

**Setup:**

1. Open two iOS simulators
2. Sign in as test1@messageai.dev on Device A
3. Sign in as test2@messageai.dev on Device B
4. Open same conversation on both devices

**Test Scenarios:**

1. **Basic Image Upload (AC #1-5):**
   - Device A: Tap attachment button (paperclip icon)
   - Device A: Select image from Photos
   - Device A: See compression progress (< 1s)
   - Device A: See upload progress overlay (0% → 100%)
   - Device B: See image message appear within 2 seconds

2. **Full-Screen View (AC #6):**
   - Device A or B: Tap image message
   - Full-screen image viewer opens
   - Double-tap to zoom
   - Pinch to zoom in/out
   - Tap close button (X) to dismiss

3. **Share Image (AC #6):**
   - Open full-screen viewer
   - Tap share button
   - iOS share sheet appears
   - Share to Messages/AirDrop/Save (optional)

4. **Large Image Compression (AC #2, #15):**
   - Select 10MB+ image
   - Observe compression (may take 2-3 seconds)
   - Verify upload size < 2MB (check Firebase Console → Storage)
   - Verify upload completes within 5 seconds on WiFi

5. **Upload Failure & Retry (AC #7):**
   - Simulate: Turn off WiFi on Device A
   - Device A: Select and send image
   - Image shows "Queued" or failed status
   - Turn WiFi back on
   - Device A: Tap retry button or wait for auto-retry
   - Upload succeeds

6. **Cancel Upload (AC #7):**
   - Start uploading large image (5MB)
   - During upload (20-50%), tap cancel button
   - Upload stops, message removed or shows cancelled state

7. **Offline Queue (AC #10):**
   - Device A: Turn off WiFi
   - Device A: Select and send image
   - Image queued locally
   - Turn WiFi back on
   - Image uploads automatically within 5 seconds

8. **Regression (AC #16):**
   - Send 5 text messages (verify all delivered)
   - Send 2 images (verify all appear)
   - Edit a text message (verify edit successful)
   - Mark messages as read (verify read receipts update)
   - Type in message input (verify typing indicator works)

### Accessibility

**VoiceOver Support:**

```swift
// Image message accessibility
imageView.isAccessibilityElement = true
imageView.accessibilityLabel = "Image message from \(senderName)"
imageView.accessibilityHint = "Double-tap to view full screen"
imageView.accessibilityTraits = .button
```

**Upload Progress Accessibility:**

```swift
progressOverlay.accessibilityLabel = "Uploading image"
progressOverlay.accessibilityValue = "\(Int(progress * 100))% complete"
```

### WCAG AA Compliance

- **Color Contrast:** Progress indicators meet 4.5:1 ratio (white on semi-transparent black)
- **Touch Targets:** Attachment button 44x44pt minimum
- **Alternative Text:** All images have accessibility labels
- **Keyboard Navigation:** Not applicable (iOS touch interface)

---

## Testing

[Source: docs/architecture/testing-strategy.md]

### Unit Tests (12-15 tests)

**File:** `MessageAITests/Presentation/Utils/ImageCompressorTests.swift`

1. `testCompressImage_Under2MB()` - Verify output < 2MB
2. `testCompressImage_LargeImage_10MB()` - 10MB input → < 2MB output
3. `testCompressImage_MaintainsAspectRatio()` - Width/height ratio preserved
4. `testCompressImage_ResizesLargeImage()` - Image > 1920px resized
5. `testCompressImage_NilForInvalidImage()` - Handles corrupt/nil image

**File:** `MessageAITests/Presentation/ViewModels/ChatViewModelImageUploadTests.swift`

6. `testSendImageMessage_Success()` - Message appended, upload called, attachment added
7. `testSendImageMessage_ProgressUpdates()` - Verify uploadProgress updated (0.0 → 1.0)
8. `testSendImageMessage_Failure()` - Verify uploadErrors set, status = .failed
9. `testRetryImageUpload()` - Retry calls uploadMessageImage again
10. `testCancelImageUpload()` - Verify cancelUpload called, message removed
11. `testOfflineImageQueue()` - Image queued when offline, uploaded when online
12. `testOptimisticUI()` - Message appears immediately with status .sending

**File:** `MessageAITests/Data/Repositories/FirebaseStorageRepositoryTests.swift`

13. `testUploadMessageImage_Success()` - Returns MessageAttachment with URL
14. `testUploadMessageImage_ProgressUpdates()` - Progress handler called with 0.3, 0.6, 1.0
15. `testUploadMessageImage_Cancellation()` - Upload cancelled, task removed

**Test Execution:**

```bash
# Run story tests during development
./scripts/test-story.sh ImageCompressorTests
./scripts/test-story.sh ChatViewModelImageUploadTests

# Run all Epic 2 tests before marking complete
./scripts/test-epic.sh 2
```

### Integration Tests (1 test)

**File:** `MessageAITests/Integration/ImageUploadIntegrationTests.swift`

**Test:** `testImageUpload_RealTimeSync()`

**Setup:**
- Requires Firebase Emulator running
- Creates two test users
- Creates conversation between users
- Generates test UIImage (solid color, 500x500)

**Steps:**
1. User A uploads image (compress, upload to Firebase Storage, send message)
2. User B observes messages (real-time listener)
3. Verify User B sees image message with attachment within 2 seconds
4. Verify attachment.type == .image
5. Verify attachment.url contains "firebasestorage.googleapis.com"
6. Verify attachment.sizeBytes > 0

**Skip if emulator not running:**

```swift
override func setUp() async throws {
    throw XCTSkip("Requires Firebase Emulator - run ./scripts/start-emulator.sh")
}
```

### Manual Testing Checklist

Execute all scenarios from "Manual Testing Workflow" section above.

**Required:**
- Two iOS simulators (or real devices)
- Test users: test1@messageai.dev, test2@messageai.dev
- Existing conversation between users
- Sample images in Photos app (various sizes: 500KB, 2MB, 10MB)

**Verification:**
- [ ] Attachment button opens photo picker (AC #1)
- [ ] Image compresses to < 2MB (AC #2)
- [ ] Upload progress shows percentage (AC #3)
- [ ] Image appears optimistically while uploading (AC #4)
- [ ] Image displays in MessageKit bubble (AC #5)
- [ ] Tap opens full-screen viewer with zoom (AC #6)
- [ ] Failed upload shows retry button (AC #7)
- [ ] Firebase Storage enforces 2MB limit (AC #8)
- [ ] Offline images queue and retry (AC #10)
- [ ] Upload completes within 5 seconds (WiFi, 2MB) (AC #15)
- [ ] Text messages, editing, read receipts still work (AC #16)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-10-22 | 1.0 | Story created - Image Attachments | Claude (SM) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

---

## QA Results

*This section will be populated by QA agent after implementation.*
