# Story 6.1: Conversation Activity Monitoring & Trigger Logic

## Status

**Draft**

---

## Story

**As a** developer,
**I want** the app to monitor conversation activity and trigger AI analysis at appropriate times,
**so that** notifications are analyzed after conversations pause, not for every single message.

---

## Acceptance Criteria

**Client-Side Activity Tracker:**
1. `ConversationActivityMonitor` service created in iOS app
2. Monitors incoming messages across all active conversations
3. Tracks conversation state: active, paused, threshold_exceeded
4. Configurable pause threshold (default: 120 seconds = 2 minutes)
5. Configurable message threshold (default: 20 messages in 10 minutes)
6. Service runs as background observer (doesn't block UI)

**Trigger Logic:**
7. **Pause Detection Trigger:** Conversation receives N messages, then pauses for X seconds → trigger analysis
8. **Active Conversation Trigger:** Conversation exceeds message threshold in time window → trigger analysis on next pause
9. **Debouncing:** Only one analysis per conversation per 5-minute window (prevent analysis spam)
10. **Current Conversation Exception:** Check if conversation is currently active by comparing conversationId with NavigationState.selectedConversationId. If match, suppress analysis (no Cloud Function call needed - client-side decision)

**Repository Integration:**
11. New repository protocol: `NotificationAnalysisRepositoryProtocol` in Domain layer
12. Method: `analyzeConversationForNotification(conversationId: String, userId: String) async throws -> NotificationDecision`
13. Firebase implementation calls Cloud Function `analyzeForNotification`
14. **ConversationActivityMonitor must be singleton:** Create as shared instance in DIContainer, injected into ChatViewModel or ConversationsListViewModel

**Testing:**
15. Unit test: Monitor tracks message timing correctly
16. Unit test: Pause detection triggers at correct threshold
17. Unit test: Active conversation suppression works (via NavigationState check)
18. Integration test: Real message flow triggers analysis call
19. Performance: Monitor adds < 50ms overhead per message

---

## Tasks / Subtasks

- [ ] Create ConversationActivityMonitor service (AC: 1-6)
  - [ ] Create `ConversationActivityMonitor.swift` in `MessageAI/Presentation/Services/`
  - [ ] Add `@MainActor` class with `ObservableObject` protocol
  - [ ] Implement message tracking with timestamp dictionary per conversation
  - [ ] Add configurable thresholds: `pauseThresholdSeconds`, `messageThresholdCount`, `messageThresholdWindow`
  - [ ] Add conversation state enum: `.active`, `.paused`, `.thresholdExceeded`
  - [ ] Implement `onNewMessage(conversationId: String)` method
  - [ ] Add debouncing logic with last analysis timestamp tracking

- [ ] Implement pause detection trigger logic (AC: 7-10)
  - [ ] Add `scheduleAnalysisTrigger(for conversationId: String, delay: TimeInterval)` using `Task.sleep`
  - [ ] Check conversation still paused after delay before triggering
  - [ ] Implement message count tracking in sliding time window
  - [ ] Add 5-minute debounce check before triggering analysis
  - [ ] Implement active conversation check using NotificationCenter or shared state
  - [ ] Cancel scheduled trigger if user opens conversation

- [ ] Create NotificationAnalysisRepositoryProtocol (AC: 11-13)
  - [ ] Create protocol in `Domain/Repositories/NotificationAnalysisRepositoryProtocol.swift`
  - [ ] Define `NotificationDecision` entity in `Domain/Entities/`
  - [ ] Create `FirebaseNotificationAnalysisRepository` in `Data/Repositories/`
  - [ ] Implement Cloud Function call using `Functions.functions().httpsCallable("analyzeForNotification")`
  - [ ] Add error handling for network failures, timeouts
  - [ ] Map Cloud Function JSON response to `NotificationDecision` entity

- [ ] Integrate with DIContainer (AC: 11)
  - [ ] Add factory method `makeConversationActivityMonitor()` to DIContainer
  - [ ] Add factory method `makeNotificationAnalysisRepository()` to DIContainer
  - [ ] Wire up dependencies

- [ ] Add message observer integration
  - [ ] Update `ChatViewModel` or `ConversationsListViewModel` to notify monitor on new messages
  - [ ] Use Combine publisher to observe new messages
  - [ ] Pass message events to `ConversationActivityMonitor.onNewMessage()`

- [ ] Write unit tests (AC: 14-16)
  - [ ] Create `ConversationActivityMonitorTests.swift` in MessageAITests
  - [ ] Test: Message timing tracked correctly
  - [ ] Test: Pause detection triggers at correct threshold
  - [ ] Test: Active conversation suppression works
  - [ ] Test: Debouncing prevents multiple triggers
  - [ ] Test: Message threshold detection works

- [ ] Write integration tests (AC: 17)
  - [ ] Create integration test with Firebase Emulator
  - [ ] Test: Real message flow triggers analysis call
  - [ ] Verify Cloud Function called with correct parameters

- [ ] Performance validation (AC: 18)
  - [ ] Measure overhead per message using Instruments
  - [ ] Verify < 50ms overhead requirement met

---

## Dev Notes

### Architecture Context

**Clean Architecture Layers:**
- **Domain:** `NotificationAnalysisRepositoryProtocol`, `NotificationDecision` entity
- **Data:** `FirebaseNotificationAnalysisRepository` (calls Cloud Function)
- **Presentation:** `ConversationActivityMonitor` (observes messages, triggers analysis)

**Dependency Flow:**
```
ConversationActivityMonitor → NotificationAnalysisRepositoryProtocol → FirebaseNotificationAnalysisRepository → Cloud Function
```

### Relevant Source Tree

**New Files:**
- `MessageAI/Presentation/Services/ConversationActivityMonitor.swift`
- `MessageAI/Domain/Repositories/NotificationAnalysisRepositoryProtocol.swift`
- `MessageAI/Domain/Entities/NotificationDecision.swift`
- `MessageAI/Data/Repositories/FirebaseNotificationAnalysisRepository.swift`
- `MessageAITests/Presentation/Services/ConversationActivityMonitorTests.swift`

**Modified Files:**
- `MessageAI/App/DIContainer.swift` - Add factory methods
- `MessageAI/Presentation/ViewModels/ChatViewModel.swift` - Integrate message observer
- `MessageAI/Presentation/ViewModels/ConversationsListViewModel.swift` - Integrate message observer

### Key Technical Decisions

**1. Background Service Pattern:**
Use singleton pattern with `@MainActor` for thread safety. The monitor observes message events via Combine publishers and doesn't block UI.

**2. Trigger Timing:**
```swift
// Pause Detection Example
func onNewMessage(conversationId: String) {
    lastMessageTime[conversationId] = Date()

    // Cancel existing trigger if any
    pendingTriggers[conversationId]?.cancel()

    // Schedule new trigger
    let task = Task {
        try await Task.sleep(nanoseconds: UInt64(pauseThresholdSeconds * 1_000_000_000))

        // Check if conversation still paused
        if let last = lastMessageTime[conversationId],
           Date().timeIntervalSince(last) >= Double(pauseThresholdSeconds) {
            await triggerAnalysis(conversationId: conversationId)
        }
    }
    pendingTriggers[conversationId] = task
}
```

**3. Active Conversation Detection:**
Use NavigationState to check which conversation user is currently viewing (simpler, no shared state):
```swift
// In ConversationActivityMonitor
@MainActor
class ConversationActivityMonitor: ObservableObject {
    private let navigationState: NavigationState

    init(navigationState: NavigationState, repository: NotificationAnalysisRepositoryProtocol) {
        self.navigationState = navigationState
        // ...
    }

    func shouldTriggerAnalysis(for conversationId: String) -> Bool {
        // Don't analyze if user is viewing this conversation
        guard navigationState.selectedConversationId != conversationId else {
            return false
        }

        // Check debouncing, pause threshold, etc.
        // ...
    }
}
```

**4. Cloud Function Integration:**
Story 6.3 will implement the actual Cloud Function. This story creates the repository protocol and Firebase implementation that calls it. The Cloud Function may not exist yet, so use mocks for testing.

### NotificationDecision Entity

```swift
// Domain/Entities/NotificationDecision.swift
struct NotificationDecision: Codable {
    let shouldNotify: Bool
    let reason: String
    let notificationText: String?
    let priority: NotificationPriority
    let timestamp: Date
}

enum NotificationPriority: String, Codable {
    case high
    case medium
    case low
}
```

### Firebase Cloud Function Call

```swift
// Data/Repositories/FirebaseNotificationAnalysisRepository.swift
func analyzeConversationForNotification(
    conversationId: String,
    userId: String
) async throws -> NotificationDecision {
    let function = Functions.functions().httpsCallable("analyzeForNotification")
    let data: [String: Any] = [
        "conversationId": conversationId,
        "userId": userId
    ]

    let result = try await function.call(data)

    guard let resultData = result.data as? [String: Any] else {
        throw RepositoryError.invalidResponse
    }

    // Map to NotificationDecision entity
    let jsonData = try JSONSerialization.data(withJSONObject: resultData)
    return try JSONDecoder().decode(NotificationDecision.self, from: jsonData)
}
```

### Testing Standards

**Test File Location:**
- Unit tests: `MessageAITests/Presentation/Services/ConversationActivityMonitorTests.swift`
- Integration tests: `MessageAITests/Integration/NotificationAnalysisIntegrationTests.swift`

**Testing Frameworks:**
- XCTest for unit and integration tests
- Use `MockNotificationAnalysisRepository` for ViewModel tests
- Firebase Emulator required for integration tests

**Test Coverage Requirements:**
- ConversationActivityMonitor: 80%+ coverage
- FirebaseNotificationAnalysisRepository: 70%+ coverage
- Integration tests cover end-to-end flow

**Testing Patterns:**
```swift
class ConversationActivityMonitorTests: XCTestCase {
    var monitor: ConversationActivityMonitor!
    var mockRepository: MockNotificationAnalysisRepository!

    override func setUp() {
        mockRepository = MockNotificationAnalysisRepository()
        monitor = ConversationActivityMonitor(repository: mockRepository)
    }

    func testPauseDetectionTriggersAnalysis() async throws {
        // Simulate messages
        monitor.onNewMessage(conversationId: "conv1")

        // Wait for pause threshold
        try await Task.sleep(nanoseconds: 121_000_000_000) // 121 seconds

        // Verify analysis triggered
        XCTAssertTrue(mockRepository.analyzeWasCalled)
        XCTAssertEqual(mockRepository.lastConversationId, "conv1")
    }
}
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
