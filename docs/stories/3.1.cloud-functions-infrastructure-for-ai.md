# Story 3.1: Cloud Functions Infrastructure for AI Services

## Status

**Draft**

---

## Story

**As a** developer,
**I want** Firebase Cloud Functions that securely call AI services,
**so that** API keys are never exposed in the client app and AI features can be triggered server-side.

---

## Acceptance Criteria

1. Cloud Functions project initialized in Firebase
2. Node.js Cloud Function created: `summarizeThread` accepting conversationId and messageIds
3. Node.js Cloud Function created: `extractActionItems` accepting conversationId and messageIds
4. Node.js Cloud Function created: `generateSmartSearchResults` accepting query and conversationIds
5. Cloud Functions authenticate requests (verify Firebase Auth token)
6. API keys for OpenAI or Anthropic stored in Firebase environment variables (not in code)
7. URLSession wrapper in iOS app to call Cloud Functions with proper authentication
8. Error handling in Cloud Functions: Rate limits, API failures, timeouts
9. Cloud Functions return structured JSON responses with AI results
10. Performance: Cloud Functions respond within 10 seconds or return timeout error
11. Cost optimization: Implement caching layer for repeated requests (same messages = cached summary)
12. Deployment: Cloud Functions deployed to Firebase dev environment
13. Integration test: iOS app calls Cloud Function, receives valid response
14. Security: Cloud Functions validate user has access to requested conversation data

---

## Previous Story Context

### Key Learnings from Story 2.12 (Epic 2 Completion)

**Testing Infrastructure Maturity:**
- Tiered testing strategy in place (story/epic/full suite)
- Firebase Emulator setup for integration tests
- Performance baseline tests established
- 89 unit tests passing across Domain, Data, Presentation layers

**Firebase Best Practices Established:**
- Server timestamps mandatory (`FieldValue.serverTimestamp()`)
- Batch writes for atomic operations
- Query limits to prevent excessive reads
- Security rules tested with emulator

**Architecture Patterns Proven:**
- Clean Architecture with repository abstraction working well
- ViewModels with @MainActor for concurrency safety
- Dependency injection via DIContainer
- Optimistic UI updates for messaging

**Key Infrastructure in Place:**
- Firebase services wrapper (FirebaseService.swift)
- DI container with factory methods for ViewModels
- Comprehensive Firestore security rules
- Offline persistence enabled by default

---

## Tasks / Subtasks

### Task 1: Initialize Firebase Cloud Functions Project (AC: 1)
- [ ] Install Firebase CLI if not already installed: `npm install -g firebase-tools`
- [ ] Verify Node.js 18+ installed (required by Cloud Functions)
- [ ] Run `firebase init functions` in project root
  - [ ] Select existing Firebase projects (messageai-dev-1f2ec, messageai-prod-4d3a8)
  - [ ] Choose TypeScript or JavaScript (recommend TypeScript for type safety)
  - [ ] Install dependencies
- [ ] Verify `functions/` directory created with:
  - [ ] `package.json` with Node.js 18 runtime
  - [ ] `index.ts` (or `index.js`) entry point
  - [ ] `tsconfig.json` (if TypeScript)
- [ ] Update `.gitignore` to exclude `functions/node_modules/`
- [ ] Document Cloud Functions setup in README.md

### Task 2: Implement `summarizeThread` Cloud Function (AC: 2, 5, 6, 8, 9, 10, 11, 15)
- [ ] Create `functions/src/summarizeThread.ts`
- [ ] Implement function signature:
  ```typescript
  export const summarizeThread = functions.https.onCall(async (data, context) => {
    // Input: { conversationId: string, messageIds?: string[] }
  })
  ```
- [ ] Add authentication check:
  ```typescript
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }
  ```
- [ ] Add input validation:
  - [ ] Verify `conversationId` is non-empty string
  - [ ] Validate `messageIds` is optional array of strings
- [ ] Implement security check (AC: 15):
  - [ ] Fetch conversation document from Firestore
  - [ ] Verify `context.auth.uid` is in `participantIds` array
  - [ ] Throw `permission-denied` error if not participant
- [ ] Implement cache lookup (AC: 11):
  - [ ] Generate cache key: `summary_${conversationId}_${latestMessageId}`
  - [ ] Query `ai_cache` collection for existing entry
  - [ ] If cache hit and not expired, return cached result
- [ ] Fetch messages from Firestore:
  - [ ] Query `messages` collection filtered by `conversationId`
  - [ ] Order by `timestamp` descending
  - [ ] Limit to 100 messages (or use provided `messageIds`)
  - [ ] Filter out deleted messages (`isDeleted: false`)
- [ ] Call AI API (placeholder - will be implemented in Story 3.5):
  - [ ] Prepare messages for LLM (format: sender name + text)
  - [ ] **PLACEHOLDER for Story 3.1**: Return mock response for testing:
    ```typescript
    // Mock response - replace with actual OpenAI call in Story 3.5
    const mockSummary = {
      summary: "This is a placeholder summary of the conversation. Actual AI integration in Story 3.5.",
      keyPoints: ["Placeholder key point 1", "Placeholder key point 2", "Placeholder key point 3"]
    };
    ```
  - [ ] Parse AI response (use mock response structure above)
- [ ] Store result in cache:
  - [ ] Save to `ai_cache` collection with 24-hour expiration
  - [ ] Schema: `{ featureType: 'summary', conversationId, messageRange, result, createdAt, expiresAt }`
- [ ] Implement error handling (AC: 8):
  - [ ] Catch rate limit errors (HTTP 429) → return `resource-exhausted`
  - [ ] Catch timeout errors → return `deadline-exceeded`
  - [ ] Catch generic errors → return `internal` with safe error message
- [ ] Add timeout configuration (AC: 10):
  ```typescript
  export const summarizeThread = functions
    .runWith({ timeoutSeconds: 60, memory: '512MB' })
    .https.onCall(async (data, context) => { ... })
  ```
- [ ] Return structured response (AC: 9):
  ```typescript
  return {
    success: true,
    summary: "...",
    cached: false,
    timestamp: new Date().toISOString()
  }
  ```

### Task 3: Implement `extractActionItems` Cloud Function (AC: 3, 5, 6, 8, 9, 10, 11, 15)
- [ ] Create `functions/src/extractActionItems.ts`
- [ ] Follow same structure as `summarizeThread`:
  - [ ] Authentication check
  - [ ] Input validation (`conversationId`, optional `messageIds`)
  - [ ] Security check (verify participant)
  - [ ] Cache lookup with key: `actionItems_${conversationId}_${latestMessageId}`
  - [ ] Fetch messages from Firestore
  - [ ] Call AI API (placeholder for Story 3.5):
    - [ ] **PLACEHOLDER for Story 3.1**: Return mock response for testing:
      ```typescript
      // Mock response - replace with actual OpenAI call in Story 3.5
      const mockActionItems = [
        { task: "Placeholder action item 1", assignee: "user123", deadline: null, sourceMessageId: "msg-1" },
        { task: "Placeholder action item 2", assignee: "user456", deadline: null, sourceMessageId: "msg-2" }
      ];
      ```
  - [ ] Store result in cache
  - [ ] Error handling (rate limits, timeouts, failures)
  - [ ] Timeout: 60 seconds, memory: 512MB
- [ ] Return structured response:
  ```typescript
  return {
    success: true,
    actionItems: [
      { task: "...", assignee: "...", deadline: null, sourceMessageId: "..." }
    ],
    cached: false,
    timestamp: new Date().toISOString()
  }
  ```

### Task 4: Implement `generateSmartSearchResults` Cloud Function (AC: 4, 5, 6, 8, 9, 10, 11, 15)
- [ ] Create `functions/src/generateSmartSearchResults.ts`
- [ ] Implement function signature:
  ```typescript
  export const generateSmartSearchResults = functions.https.onCall(async (data, context) => {
    // Input: { query: string, conversationIds?: string[] }
  })
  ```
- [ ] Add authentication check
- [ ] Add input validation:
  - [ ] Verify `query` is non-empty string (max 200 characters)
  - [ ] Validate `conversationIds` is optional array of strings
- [ ] Implement security check (AC: 15):
  - [ ] If `conversationIds` provided, verify user is participant in all
  - [ ] If not provided, query user's conversations from Firestore
- [ ] Implement cache lookup (AC: 11):
  - [ ] Cache key: `search_${queryHash}_${conversationIdsHash}`
  - [ ] Return cached results if < 5 minutes old
- [ ] Fetch relevant messages:
  - [ ] Query messages in specified conversations
  - [ ] Apply basic keyword filtering (preprocessing)
  - [ ] Limit to 100 most recent messages
- [ ] Call AI API (placeholder for Story 3.5):
  - [ ] Send query + messages to LLM
  - [ ] Request ranked results
  - [ ] **PLACEHOLDER for Story 3.1**: Return mock response for testing:
    ```typescript
    // Mock response - replace with actual OpenAI call in Story 3.5
    const mockSearchResults = [
      { messageId: "msg-1", conversationId: "conv-1", relevanceScore: 0.95, snippet: "Placeholder search result 1..." },
      { messageId: "msg-2", conversationId: "conv-1", relevanceScore: 0.87, snippet: "Placeholder search result 2..." }
    ];
    ```
- [ ] Store result in cache with 5-minute expiration
- [ ] Error handling: rate limits, timeouts, failures
- [ ] Timeout: 60 seconds, memory: 512MB
- [ ] Return structured response:
  ```typescript
  return {
    success: true,
    results: [
      { messageId: "...", conversationId: "...", relevanceScore: 0.95, snippet: "..." }
    ],
    cached: false,
    timestamp: new Date().toISOString()
  }
  ```

### Task 5: Configure Environment Variables for AI API Keys (AC: 6)
- [ ] Set Firebase environment variables:
  ```bash
  firebase functions:config:set openai.api_key="sk-..." --project=messageai-dev-1f2ec
  ```
- [ ] Document in README.md:
  - [ ] How to obtain OpenAI API key
  - [ ] How to set environment variables
  - [ ] How to access in Cloud Functions: `functions.config().openai.api_key`
- [ ] Add placeholder check in functions:
  ```typescript
  const apiKey = functions.config().openai?.api_key;
  if (!apiKey) {
    throw new functions.https.HttpsError('failed-precondition', 'OpenAI API key not configured');
  }
  ```

### Task 6: Create AIServiceProtocol in Domain Layer
- [ ] Create `MessageAI/Domain/Repositories/AIServiceProtocol.swift`:
  ```swift
  protocol AIServiceProtocol {
      func summarizeThread(conversationId: String, messageIds: [String]?) async throws -> ThreadSummary
      func extractActionItems(conversationId: String, messageIds: [String]?) async throws -> [ActionItem]
      func generateSmartSearchResults(query: String, conversationIds: [String]?) async throws -> [SearchResult]
  }
  ```
- [ ] Define response types in `MessageAI/Domain/Entities/`:
  - [ ] `ThreadSummary`: `{ summary: String, keyPoints: [String], timestamp: Date, cached: Bool }`
  - [ ] `ActionItem`: Already defined in database schema
  - [ ] `SearchResult`: `{ messageId: String, conversationId: String, snippet: String, relevanceScore: Double }`

### Task 7: Create iOS CloudFunctionsService Wrapper (AC: 7)
- [ ] Create `MessageAI/Data/Network/CloudFunctionsService.swift`
- [ ] Initialize Firebase Functions:
  ```swift
  import FirebaseFunctions

  class CloudFunctionsService {
      private let functions: Functions

      init() {
          self.functions = Functions.functions()
      }
  }
  ```
- [ ] Implement `callSummarizeThread`:
  ```swift
  func callSummarizeThread(conversationId: String, messageIds: [String]? = nil) async throws -> SummaryResponse {
      let data: [String: Any] = [
          "conversationId": conversationId,
          "messageIds": messageIds ?? []
      ]

      let result = try await functions.httpsCallable("summarizeThread").call(data)

      guard let response = result.data as? [String: Any] else {
          throw CloudFunctionsError.invalidResponse
      }

      return try parseSummaryResponse(response)
  }
  ```
- [ ] Implement `callExtractActionItems`:
  ```swift
  func callExtractActionItems(conversationId: String, messageIds: [String]? = nil) async throws -> ActionItemsResponse
  ```
- [ ] Implement `callGenerateSmartSearchResults`:
  ```swift
  func callGenerateSmartSearchResults(query: String, conversationIds: [String]? = nil) async throws -> SearchResultsResponse
  ```
- [ ] Add response DTOs:
  - [ ] `SummaryResponse`: `{ success: Bool, summary: String, cached: Bool, timestamp: String }`
  - [ ] `ActionItemsResponse`: `{ success: Bool, actionItems: [ActionItemDTO], cached: Bool, timestamp: String }`
  - [ ] `SearchResultsResponse`: `{ success: Bool, results: [SearchResultDTO], cached: Bool, timestamp: String }`
- [ ] Error handling:
  - [ ] Map Firebase Functions errors to Swift errors
  - [ ] Handle `unauthenticated`, `permission-denied`, `resource-exhausted`, `deadline-exceeded`, `internal`
- [ ] Add to DIContainer:
  ```swift
  private let cloudFunctionsService = CloudFunctionsService()
  ```

### Task 8: Implement FirebaseAIService in Data Layer
- [ ] Create `MessageAI/Data/Repositories/FirebaseAIService.swift`:
  ```swift
  class FirebaseAIService: AIServiceProtocol {
      private let cloudFunctionsService: CloudFunctionsService

      init(cloudFunctionsService: CloudFunctionsService) {
          self.cloudFunctionsService = cloudFunctionsService
      }

      func summarizeThread(conversationId: String, messageIds: [String]?) async throws -> ThreadSummary {
          let response = try await cloudFunctionsService.callSummarizeThread(
              conversationId: conversationId,
              messageIds: messageIds
          )

          return ThreadSummary(
              summary: response.summary,
              keyPoints: [], // Will be populated in Story 3.2
              timestamp: ISO8601DateFormatter().date(from: response.timestamp) ?? Date(),
              cached: response.cached
          )
      }

      func extractActionItems(conversationId: String, messageIds: [String]?) async throws -> [ActionItem] { ... }

      func generateSmartSearchResults(query: String, conversationIds: [String]?) async throws -> [SearchResult] { ... }
  }
  ```
- [ ] Add to DIContainer:
  ```swift
  private lazy var aiService: AIServiceProtocol =
      FirebaseAIService(cloudFunctionsService: cloudFunctionsService)
  ```

### Task 9: Deploy Cloud Functions to Firebase Dev Environment (AC: 12)
- [ ] Deploy to dev environment:
  ```bash
  firebase deploy --only functions --project=messageai-dev-1f2ec
  ```
- [ ] Verify deployment in Firebase Console:
  - [ ] Check Functions section shows all 3 functions
  - [ ] Verify runtime is Node.js 18
  - [ ] Check logs for any deployment errors
- [ ] Test functions via Firebase Console:
  - [ ] Use "Test" feature to invoke functions manually
  - [ ] Verify authentication errors when no user context
- [ ] Document deployment process in README.md:
  - [ ] Command to deploy functions
  - [ ] How to view logs: `firebase functions:log --project=messageai-dev-1f2ec`
  - [ ] How to delete functions if needed

### Task 10: iOS Integration Test (AC: 13)
- [ ] Create `MessageAITests/Integration/CloudFunctionsIntegrationTests.swift`:
  ```swift
  class CloudFunctionsIntegrationTests: XCTestCase {
      var cloudFunctionsService: CloudFunctionsService!

      override func setUp() async throws {
          try await super.setUp()

          // Skip if emulator not running
          try XCTSkipIf(true, "Requires Firebase Emulator - start with ./scripts/start-emulator.sh")

          // Configure for emulator
          Functions.functions().useEmulator(withHost: "localhost", port: 5001)

          cloudFunctionsService = CloudFunctionsService()
      }

      func testSummarizeThread_Success() async throws {
          // Create test conversation and messages in emulator
          let conversationId = "test-conversation-1"

          // Call function
          let response = try await cloudFunctionsService.callSummarizeThread(
              conversationId: conversationId
          )

          XCTAssertTrue(response.success)
          XCTAssertFalse(response.summary.isEmpty)
      }

      func testExtractActionItems_Success() async throws { ... }

      func testGenerateSmartSearchResults_Success() async throws { ... }

      func testSummarizeThread_Unauthenticated() async throws {
          // Sign out user
          // Expect authentication error
      }
  }
  ```
- [ ] Run integration tests with emulator:
  ```bash
  ./scripts/start-emulator.sh &
  ./scripts/quick-test.sh --test CloudFunctionsIntegrationTests --with-integration
  ```

### Task 11: Update Firestore Security Rules for AI Cache (AC: 14)
- [ ] Add security rules for `ai_cache` collection in `firestore.rules`:
  ```javascript
  match /ai_cache/{cacheId} {
    allow read: if isAuthenticated();
    allow write: if false;  // Only Cloud Functions write to cache
  }
  ```
- [ ] Create/update `firestore.indexes.json` with ai_cache composite index:
  ```json
  {
    "indexes": [
      {
        "collectionGroup": "ai_cache",
        "fields": [
          { "fieldPath": "conversationId", "order": "ASCENDING" },
          { "fieldPath": "featureType", "order": "ASCENDING" },
          { "fieldPath": "expiresAt", "order": "ASCENDING" }
        ]
      }
    ]
  }
  ```
- [ ] Deploy security rules and indexes:
  ```bash
  firebase deploy --only firestore:rules,firestore:indexes --project=messageai-dev-1f2ec
  ```
- [ ] Test rules with Firebase Emulator:
  - [ ] Verify authenticated users can read cache entries
  - [ ] Verify client cannot write to cache (Cloud Functions only)

### Task 12: Documentation and README Updates
- [ ] Update `README.md` with Cloud Functions section:
  - [ ] How to set up Cloud Functions locally
  - [ ] How to deploy Cloud Functions
  - [ ] How to configure API keys
  - [ ] How to test Cloud Functions
- [ ] Create `functions/README.md`:
  - [ ] Project structure
  - [ ] Local development workflow
  - [ ] Testing strategy
  - [ ] Deployment instructions
- [ ] Document environment variables:
  - [ ] `openai.api_key` (to be set in Story 3.5)
  - [ ] Future: rate limit configs, cache TTL configs

---

## Dev Notes

### Tech Stack for Cloud Functions

[Source: docs/architecture/tech-stack.md]

- **Cloud Functions Runtime**: Firebase Cloud Functions with Node.js 18
- **AI Provider**: OpenAI GPT-4 (gpt-4-turbo) - Alternative: Anthropic Claude 3
- **Testing Framework**: Jest 29.x for Node.js unit testing
- **Cloud Functions Purpose**:
  - Protects API keys from client exposure
  - Executes AI calls server-side
  - Automatic scaling and pay-per-execution pricing

### Cloud Functions Coding Standards

[Source: docs/architecture/coding-standards.md#cloud-functions-coding-standards]

**Critical Rules:**

1. **Validate Inputs Immediately**
   - Check `context.auth` exists
   - Validate all input parameters
   - Return structured error responses

2. **Idempotent Operations**
   - Functions should be safe to retry
   - Use transaction IDs to detect duplicates

3. **Timeouts and Error Handling**
   - Set timeout: 60 seconds max for AI functions
   - Catch all errors, never let functions crash
   - Log errors to Cloud Logging

4. **Cache Aggressively**
   - Check `ai_cache` collection before calling LLM
   - Set 24-hour expiration for cached results
   - **Why**: Cost optimization (LLM calls expensive)

### AI Cache Schema

[Source: docs/architecture/database-schema.md#firestore-collections]

**ai_cache/ collection:**
```
{
  id: string
  featureType: string (enum: "summary", "actionItems", "search")
  conversationId: string [INDEXED]
  messageRange: string
  messageCount: number
  latestMessageId: string
  result: string (JSON)
  createdAt: timestamp
  expiresAt: timestamp [INDEXED - TTL]
  schemaVersion: number
}
```

**Composite Index:**
```json
{
  "collectionGroup": "ai_cache",
  "fields": [
    { "fieldPath": "conversationId", "order": "ASCENDING" },
    { "fieldPath": "featureType", "order": "ASCENDING" },
    { "fieldPath": "expiresAt", "order": "ASCENDING" }
  ]
}
```

### iOS Architecture Integration

[Source: docs/architecture/ios-app-architecture.md]

**CloudFunctionsService Location**: `MessageAI/Data/Network/CloudFunctionsService.swift`

**Integration Pattern**:
```
ViewModel (Presentation)
    ↓ depends on
AIServiceProtocol (Domain)
    ↑ implemented by
FirebaseAIService (Data)
    ↓ uses
CloudFunctionsService (Data/Network)
    ↓ calls
Firebase Cloud Functions (Backend)
```

**Dependency Injection**: CloudFunctionsService created in DIContainer as singleton, injected into FirebaseAIService

### Firestore Security Rules

[Source: docs/architecture/database-schema.md#firestore-security-rules]

**AI Cache Access Control**:
```javascript
match /ai_cache/{cacheId} {
  allow read: if isAuthenticated();
  allow write: if false;  // Only Cloud Functions write to cache
}
```

**Message Access Validation** (for Cloud Functions to verify participant access):
```javascript
match /conversations/{conversationId} {
  allow read: if isParticipant(resource.data);
}

function isParticipant(conversationData) {
  return isAuthenticated() &&
         request.auth.uid in conversationData.participantIds;
}
```

### Error Handling Patterns

[Source: docs/architecture/coding-standards.md]

**Cloud Functions Error Responses**:
- `unauthenticated`: User not logged in
- `permission-denied`: User not participant in conversation
- `invalid-argument`: Missing or invalid input parameters
- `resource-exhausted`: Rate limit exceeded
- `deadline-exceeded`: Function timeout (> 60 seconds)
- `internal`: Generic server error

**iOS Error Mapping**:
```swift
enum CloudFunctionsError: Error {
    case unauthenticated
    case permissionDenied
    case invalidInput(String)
    case rateLimitExceeded
    case timeout
    case serverError(String)
}
```

### Cache Strategy

[Source: docs/architecture/coding-standards.md#cloud-functions-coding-standards]

**Cache Key Generation**:
- Summary: `summary_${conversationId}_${latestMessageId}`
- Action Items: `actionItems_${conversationId}_${latestMessageId}`
- Search: `search_${queryHash}_${conversationIdsHash}`

**Cache Expiration**:
- Summaries and Action Items: 24 hours
- Search results: 5 minutes (more volatile)

**Cache Invalidation**:
- New message arrives → latestMessageId changes → new cache key → fresh result
- User can manually regenerate (bypasses cache)

### Performance Requirements

[Source: Epic 3 PRD Story 3.1 AC]

- **Cloud Function Response Time**: < 10 seconds
- **Cache Hit Response Time**: < 1 second
- **Timeout Handling**: Functions must timeout gracefully after 60 seconds
- **Cost Optimization Goal**: 70%+ cache hit rate

### Project Structure for Cloud Functions

**New Directory Structure**:
```
functions/
├── src/
│   ├── index.ts                    # Entry point, exports all functions
│   ├── summarizeThread.ts          # Thread summarization function
│   ├── extractActionItems.ts      # Action item extraction function
│   ├── generateSmartSearchResults.ts  # Smart search function
│   ├── utils/
│   │   ├── cache.ts               # Cache lookup/storage helpers
│   │   ├── security.ts            # Participant validation helpers
│   │   └── aiClient.ts            # AI API client (Story 3.5)
│   └── __tests__/
│       ├── summarizeThread.test.ts
│       ├── extractActionItems.test.ts
│       └── generateSmartSearchResults.test.ts
├── package.json
├── tsconfig.json
└── .gitignore
```

### Testing Standards

[Source: docs/architecture/testing-strategy.md]

**Unit Testing Approach**:
- Mock Firestore SDK for database interactions
- Mock AI API responses (avoid actual API calls in tests)
- Test authentication, validation, error handling independently
- Use Jest with `@types/jest` and `ts-jest`

**Integration Testing Approach**:
- Use Firebase Emulator for Cloud Functions
- Gracefully skip if emulator not running
- Test end-to-end flow: iOS app → Cloud Function → Firestore

**Test Commands**:
- Cloud Functions unit tests: `cd functions && npm test`
- iOS integration tests: `./scripts/quick-test.sh --with-integration`

### Known Constraints and Notes

**Firebase Blaze Plan Required**:
- Free tier (Spark plan) does not support Cloud Functions calling external APIs
- Blaze plan (pay-as-you-go) required for OpenAI API calls
- [Source: Epic 3 Scope external dependencies]

**Node.js Version**:
- Must use Node.js 18+ (Firebase Cloud Functions requirement)
- Verify with: `node --version`

**AI API Placeholder**:
- Story 3.1 focuses on infrastructure only
- AI API integration (OpenAI) will be completed in Story 3.5
- Functions should have placeholder logic that returns mock responses for now

**Environment Variable Access**:
- Set with: `firebase functions:config:set key="value"`
- Access with: `functions.config().key`
- Local development: Use `.runtimeconfig.json` (gitignored)

### Related Architecture Documents

- [Tech Stack](../architecture/tech-stack.md) - Cloud Functions runtime and AI provider selection
- [Coding Standards](../architecture/coding-standards.md#cloud-functions-coding-standards) - Cloud Functions best practices
- [Database Schema](../architecture/database-schema.md) - ai_cache collection schema and security rules
- [iOS App Architecture](../architecture/ios-app-architecture.md) - CloudFunctionsService integration
- [Testing Strategy](../architecture/testing-strategy.md) - Jest setup and testing approach

---

## Testing

[Source: docs/architecture/testing-strategy.md]

### iOS Integration Tests

**Test File Location**: `MessageAITests/Integration/CloudFunctionsIntegrationTests.swift`

**Test Requirements**:
- Requires Firebase Emulator running
- Tests gracefully skip if emulator unavailable
- Use `XCTSkipIf` for emulator dependency

**Test Scenarios**:
1. Successful function call with valid authentication
2. Function call fails when unauthenticated
3. Function call fails for non-participant user
4. Response parsing and DTO mapping
5. Error handling for network failures

**Sample Test**:
```swift
func testSummarizeThread_Success() async throws {
    // Arrange: Create test data in emulator
    let conversationId = "test-conversation-1"
    // ... create conversation and messages

    // Act: Call Cloud Function
    let response = try await cloudFunctionsService.callSummarizeThread(
        conversationId: conversationId
    )

    // Assert: Verify response
    XCTAssertTrue(response.success)
    XCTAssertFalse(response.summary.isEmpty)
    XCTAssertNotNil(response.timestamp)
}
```

### Testing Workflow

**Before Marking Story Complete**:
```bash
# Run iOS integration tests (with emulator)
./scripts/start-emulator.sh &
./scripts/quick-test.sh --test CloudFunctionsIntegrationTests --with-integration
```

**Tier 1 Story Tests** (5-20 seconds):
```bash
# Test only Cloud Functions integration
./scripts/test-story.sh CloudFunctionsIntegrationTests
```

**Tier 2 Epic Tests** (20-40 seconds):
```bash
# Test all Epic 3 features (when more stories added)
./scripts/test-epic.sh 3
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Initial story draft created | Scrum Master (Bob) |
| 2025-10-22 | 1.1 | Story validated and fixed: Reordered Tasks 6-8 for Clean Architecture (Domain→Data layer), added explicit AI placeholder mock structures to Tasks 2-4, added Firestore indexes deployment to Task 12 | Product Owner (Sarah) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

---

### Debug Log References

_To be filled by Dev Agent_

---

### Completion Notes List

_To be filled by Dev Agent_

---

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
